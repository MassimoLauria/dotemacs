#+title: Massimo's Emacs configuration
#+author: Massimo Lauria <massimo.lauria@uniroma1.it>
#+STARTUP: collapsed

This is the Emacs config of Massimo Lauria (C) 2009-2021.

This configuration  is under massive  and continue change,  and things
break every day. I just put it  online so you can cut & paste whatever
you may find useful.

This configuration assume a modern  Emacs installation (>=24). If your
Emacs  is less  recent than  that,  the configuration  will revert  to
a minimal version.

*Literate configuration*: this Emacs configuration is on the way to be
a /literate configuration/  developed as an =org-mode=  file. The plan
is that the very  document you are reading right now  will be the main
part of the  configuration itself. At this point this  is not true but
I am  putting in place the  infrastructure for it. I  will slowly move
part of the main config inside this =README.org= file.

* Bootstrapping the setup

  The   variable  =base-config-path=   keeps   the   path  where   the
  configuration is  installed. I add  that to the =load-path=,  and we
  also add the path of 3rd parties packages, which are packages I keep
  in the repository because they are not on =melpa= (yet).

#+BEGIN_SRC emacs-lisp
(setq 3rdparties-packages-path (concat base-config-path "3rdparties/"))

(add-to-list 'load-path base-config-path)
(add-to-list 'load-path 3rdparties-packages-path)
#+END_SRC

  The best way to  read Info files is in emacs.  The client merges all
  info /dir/  files in  a single index.  Therefore among  other things
  I  make  the  index  to  show  my  local  info  documents  as  well.
  For example  my copy  of "Structure  and Interpretation  of Computer
  Programs".

#+BEGIN_SRC emacs-lisp
(if (not (boundp 'Info-directory-list))
    (setq Info-directory-list nil))
(add-to-list 'Info-directory-list (concat base-config-path "/info"))
#+END_SRC

** Adjust =PATH= environment variables

   When Emacs is  lauched as an app  (on MacOSX) or from  a gui command
   (in linux)  there is often  the chance that the  running environment
   does not contain some environment variables  or does not set them up
   appropriately. These  functions allow me  to care of such  issues as
   long as they arise in my setup. I don't claim any generality here.

   First  I have  two functions  to manage  variables for  the runtime
   environment where Emacs has been executed from.

#+BEGIN_SRC emacs-lisp
(defun environment-variable-add-to-list (varname element &optional append)
  "Add ELEMENT from the list in the enviroment variable VARNAME.

VARNAME is considered as a list of elements like \"aa:bb:cc\". If
VARNAME is undefined of empty, it defines it. If ELEMENT is
already in the list, the function won't do anything.

There is no guarantee on the actual order of the elements in the
list."
  (let ((separator (if (eq system-type 'windows-nt) ";" ":"))
        tmplist)
    (if (getenv varname)
        (setq tmplist (split-string
                       (getenv varname)
                       separator)))
    (add-to-list 'tmplist element append 'string-equal)
    (setenv varname (mapconcat 'identity tmplist ":"))))

(defun environment-variable-rm-from-list (varname element)
  "Remove ELEMENT from the list in the enviroment variable VARNAME.

VARNAME is considered as a list of elements like \"aa:bb:cc\". If
ELEMENT is not in the list, the function won't do anything.

There is no guarantee on the actual order of the elements in the
list."
  (let ((separator (if (eq system-type 'windows-nt) ";" ":"))
        tmplist)
    (if (getenv varname)
        (setq tmplist (split-string
                       (getenv varname)
                       separator)))
    (setenv varname (mapconcat 'identity (remove element tmplist) ":"))))


#+END_SRC

   I use this functions primarily to fix =PATH=.

#+BEGIN_SRC emacs-lisp
(defun environment-add-path (newpath &optional append)
  "Add NEWPATH to the PATH environment variable and to exec-path,

Ignore if the path does not exists."
  (when (file-directory-p newpath)
    (add-to-list 'exec-path newpath append 'string-equal)
    (environment-variable-add-to-list "PATH" newpath append)))
#+END_SRC

   Some useful  paths to add  to the environment. In  particular tools
   like =Cask=,  =cabal=, =cargo=, install their  executables files in
   a corresponding hidden folder inside =$HOME=.

#+BEGIN_SRC emacs-lisp
(environment-add-path "/usr/local/bin")                        ;; Homebrew  (MacOS)
(environment-add-path (concat (getenv "HOME") "/.cask/bin"))   ;; Cask      (for Elisp)
(environment-add-path (concat (getenv "HOME") "/.local/bin"))  ;; Local/bin (GNU/Linux)
#+END_SRC


  Actually the  right way to set  system-wide exec-paths on Mac  is to
  use `/etc/paths.d' files. I pick up these paths as well.

#+BEGIN_SRC emacs-lisp
(with-temp-buffer
  (condition-case nil
      (dolist (file (cons "/etc/paths" (directory-files "/etc/paths.d/" t)))
        (if (not (file-directory-p file))
            (insert-file-contents file)))
    (error nil))

  (dolist (path (split-string (buffer-string) "\n" t))
    (if (file-directory-p path)
        (environment-add-path path))))
#+END_SRC



** Private configuration

   Part of my setup  is not for the public eye and  is not included in
   the repository.

#+BEGIN_SRC emacs-lisp
(let ((private "~/personal/conf/emacs.el"))
  (when (file-readable-p private)
    (load-file private)))
#+END_SRC


* Localization/Internationalization

#+BEGIN_SRC emacs-lisp
(setenv "LANG" "it_IT.UTF-8")
#+END_SRC


** Keyboard

   Naturally I have my keyboard minor mode.

#+BEGIN_SRC emacs-lisp
;; My keyboard configuration
(use-package mxl-keyboard
  :commands (mxl-keyboard-mode mxl-keyboard-global-mode)
  :diminish ""
  :config
  (mxl-keyboard-global-mode)
  :demand t)
#+END_SRC

  I often  type =C-x C-z=  by mistake,  which hides the  current Emacs
  frame via =susped-frame=. I hate it.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-z") 'nil)
#+END_SRC


** Text encoding is always UTF-8

   I work  mostly with UTF-8 file,  Hence UTF-8 is the  default coding
   for buffers.

#+BEGIN_SRC emacs-lisp
(prefer-coding-system       'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(setq default-buffer-file-coding-system 'utf-8)
#+END_SRC

   The same setting seems to be needed for the clipboard.

#+BEGIN_SRC emacs-lisp
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
(set-clipboard-coding-system 'utf-8)
#+END_SRC

   I often need to write greek or  math symbols (e.g. α, ⊕), and since
   I know LaTeX it is convenient to use the same markup to insert them
   in regular text. Nevertheless it is inconvenient to have that on by
   default.    I    activate    it   when    needed    typing    =C-\=
   (=toggle-input-method=).

#+BEGIN_SRC emacs-lisp
(setq default-input-method 'TeX)
(set-input-method nil)
#+END_SRC


** Italians holidays, timezones and calendar names

   For  me it  is  useful to  have  the agenda  to  remind of  italian
   holidays,  especially   if  they  corresponds  to   vacation  days.
   I override the  original values of these variables  because I don't
   care to know about holidays that do not affect me.

#+BEGIN_SRC emacs-lisp

;; Non-religious holidays
(setq holiday-general-holidays
      '((holiday-fixed 1 1 "Capodanno")
        (holiday-fixed 3 8 "Giornata internazionale della donna")
        (holiday-fixed 5 1 "Festa dei Lavoratori")
        (holiday-fixed 4 25 "Liberazione dal Nazifascismo")
        (holiday-fixed 6 2 "Festa della Repubblica")))

;; Catholics holidays that induce vacations
(setq holiday-christian-holidays
     '((holiday-fixed 12 8 "Immacolata Concezione")
       (holiday-fixed 12 25 "Natale")
       (holiday-fixed 12 26 "Santo Stefano")
       (holiday-fixed 1 6 "Epifania")
       (holiday-easter-etc -52 "Giovedì grasso")
       (holiday-easter-etc -47 "Martedì grasso")
       (holiday-easter-etc   0 "Pasqua")
       (holiday-easter-etc  +1 "Pasquetta")
       (holiday-fixed 8 15 "Ferragosto")
       (holiday-fixed 11 1 "Ognissanti")))

;; No other religious holidays induce vacation days in Italy.
(setq holiday-bahai-holidays nil)
(setq holiday-hebrew-holidays nil)
(setq holiday-islamic-holidays nil)
#+END_SRC

   In  Italy the  weekly  calendar  starts from  Monday,  hence I  set
   =calendar-week-start-day= accordingly. It is  also nice to have the
   names of months and weekdays translated.

#+BEGIN_SRC emacs-lisp
(setq calendar-week-start-day 1
      calendar-day-name-array ["Domenica" "Lunedì" "Martedì" "Mercoledì"
                               "Giovedì" "Venerdì" "Sabato"]
      calendar-month-name-array ["Gennaio" "Febbraio" "Marzo" "Aprile" "Maggio"
                                 "Giugno" "Luglio" "Agosto" "Settembre"
                                 "Ottobre" "Novembre" "Dicembre"])
#+END_SRC

   Several packages (e.g.  Org-mode) need to recognize  what a weekday
   name  or  a  month  name is.  Package  =parse-time=  provides  this
   functionality, but it only knows about English words. I can add the
   Italian ones to  ~parse-time-weekdays~ and ~parse-time-months~ when
   package =parse-time= is loaded. I also add the timezones.

#+BEGIN_SRC emacs-lisp :tangle no
(defconst parse-time-weekdays
  '(("dom" . 0) ("lun" . 1) ("mar" . 2) ("mer" . 3) ("gio" . 4) ("ven" . 5) ("sab" . 6)
    ("domenica" . 0) ("lunedì" .  1) ("martedì" . 2) ("mercoledì" . 3)
    ("giovedì" .  4) ("venerdì" . 5) ("sabato" .  6))
  "Italian weekdays to add to `parse-time-weekdays'.")


(defconst parse-time-months-ita
  '(("gen" . 1) ("feb" . 2) ("mar" . 3) ("apr" .  4) ("mag" .  5) ("giu" .  6)
    ("lug" . 7) ("ago" . 8) ("set" . 9) ("ott" . 10) ("nov" . 11) ("dic" . 12)
    ("gennaio" . 1)   ("febbraio" . 2) ("marzo" . 3)     ("aprile" . 4)
    ("maggio" . 5)    ("giugno" . 6)   ("luglio" . 7)    ("agosto" . 8)
    ("settembre" . 9) ("ottobre" . 10) ("novembre" . 11) ("dicembre" . 12))
  "Italian manths to add to `parse-time-months'.")

(use-package parse-time
  :config
  (setq parse-time-months   (append parse-time-months parse-time-months-ita))
  (setq parse-time-weekdays (append parse-time-weekdays parse-time-weekdays-ita))
  (add-to-list 'parse-time-zoneinfo  '("cet" 3600 t) t)  ;; Central European Time
  (add-to-list 'parse-time-zoneinfo  '("cest" 7200)  t)  ;; Central European Summer Time
  )
#+END_SRC





* Appearance
** Fonts

The most important visual setup for a  text editor is the font. We set
the default  font. The =symbol-font=  is the fallback needed  for some
math symbols.

#+BEGIN_SRC emacs-lisp
;(setq default-font "Fira Code")
(setq default-font "DejaVu Sans Mono")
;(setq default-font "Menlo")
;(setq default-font "Inconsolata")
;(setq default-font "Source Code Pro")

(setq symbol-font "DejaVu Sans Mono")

(set-face-attribute 'default nil
                    :family "DejaVu Sans Mono"
                    :width 'normal
                    :height 180)
#+END_SRC

   I like Emacs to  open in a wide frame at the  center of the screen,
   on  startup,  at  least  on  these  systems  with  floating  window
   managers. No internal border except for  a small fringe on the left
   side. I disable  any other decorations. Text is  more readable with
   some additional space between lines.

#+BEGIN_SRC emacs-lisp
(setq initial-frame-alist '((top . 0.5)    ;; center vertical position
                            (left . 0.5))) ;; center horizontal position


(setq default-frame-alist `((height . 64)
                            (width . 120)
                            (tool-bar . nil)
                            (line-spacing . 0.2)
                            (internal-border-width . 0)
                            (border-width . 0)
                            (vertical-scroll-bars . nil)
                            (horizontal-scroll-bars . nil)
                            (left-fringe . 8)
                            (right-fringe . 0)
                            (tool-bar-lines . 0)
                            (menu-bar-line . 0)
                            ))
#+END_SRC

Some glyphs  are not  includes in  the default  font, thus  emacs uses
a  fallback which  sometimes  is less  than  desirable. In  particular
this messes  up the  alignment in  ~helm-bibtex~. For  such characters
I use an alternative fallback font.

*Hint:* To  discover the  properties of  some text  on the  screen the
command ~C-u C-x =~ gives them all: font, style, font-lock, char code.

#+BEGIN_SRC emacs-lisp
(defun mxl-fix-bibfonts (frame)
  (set-fontset-font t #x2318 symbol-font)   ; ⌘
  (set-fontset-font t #x270e symbol-font)   ; ✎
  ;;(set-fontset-font t nil "Symbola")
  )       ; other fonts like 😊 💾  

(mapc 'mxl-fix-bibfonts (frame-list))                    ; applies to existing frames
(add-hook 'after-make-frame-functions 'mxl-fix-bibfonts) ; applies to future frames
#+END_SRC

** Theme

   The color  theme i use  is Zenburn, which features  Dark background
   and low contrast. I wonder if it is good for the eyes.

#+BEGIN_SRC emacs-lisp
;; Set theme to zenburn
(use-package zenburn-theme
  :config
  (load-theme 'zenburn t))
#+END_SRC

   Syntax/Spell  checkers  add  decorations  to  the  text  to  signal
   mistakes.  The defaults  decorations  from Zenburn  are either  too
   intrusive or too faint, so I customize them.

   - Violet for spelling/grammar mistakes
   - Red for syntax mistakes in programming languages
   - Yellow for syntax/style warnings
   - Green for syntax/style notes

#+BEGIN_SRC emacs-lisp
(custom-theme-set-faces
 'zenburn
 '(mode-line ((t (:box nil))))
 '(mode-line-inactive ((t (:box nil))))
 '(flycheck-error ((t (:underline "Red"))))
 '(flycheck-warning ((t (:underline "Yellow"))))
 '(flycheck-info ((t nil)))
 '(flymake-error ((t (:underline "Red1"))))
 '(flymake-warning ((t (:underline "yellow"))))
 '(flymake-note ((t (:underline "deep sky blue"))))
 '(flyspell-duplicate ((t (:underline (:color "magenta" :style wave)))))
 '(flyspell-incorrect ((t (:underline (:color "magenta" :style wave)))))
 '(writegood-duplicates-face ((t nil)))
 '(writegood-passive-voice-face ((t (:underline (:color "magenta" :style wave)))))
 '(writegood-weasels-face ((t (:underline (:color "magenta" :style wave))))))
#+END_SRC

** Modeline customization

   We use Doom Emacs Modeline (see [[https://github.com/seagle0128/doom-modeline][here]]). Many other customizations of
   the modeline that I used to  do are incompatible, or even obsolete,
   with this modeline engine. Maybe I could personalize it better from
   scratch, but  most of  my solutions  were hacks  and were  not well
   integrated with the  rest of Emacs. Doom Modeline  is minimal, well
   organized and nice to look at (especially with icons enabled).

   Furthermore I  will likely  support functionalities that  I haven't
   decided to use yet (e.g. mu4e or github integration).
  
#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  :ensure t
  :init
  (setq doom-modeline-icon t)
  (setq doom-modeline-bar-width 6)
  (setq doom-modeline-major-mode-icon t)
  (setq doom-modeline-enable-word-count t)
  (setq pyenv-mode-mode-line-format "")
  (doom-modeline-mode 1))
#+END_SRC


*** COMMENT Renaming major modes
    :PROPERTIES:
    :header-args: :tangle no
    :END:

    *Note:*  this  is   incompatible  with  =doom-modeline=  therefore
    I disable the whole setup described below.
    
    To make the modeline cleaner and more cute, I will rename the major
    mode so  to make it  more compact. The  list of abbreviation  is an
    ~alist~ named  =rename-major-mode-alist= where  each pair in  it is
    the major mode and new representation.

#+BEGIN_SRC emacs-lisp
(defvar rename-major-mode-alist
  `((lisp-interaction-mode . "λ")
    (emacs-lisp-mode . "λ")
    (inferior-emacs-lisp-mode . "iλ")
    (python-mode . "Py"))
  "Alist for `rename-major-mode-alist'.")
#+END_SRC

   To apply the renaming scheme we need the following code.

#+BEGIN_SRC emacs-lisp
(defun rename-major-mode-line ()
  "Change the major mode name in the mode-line.

The renaming table is `rename-major-mode-alist'."
  (interactive)
  (loop for cleaner in rename-major-mode-alist
        do (let* ((mode (car cleaner))
                 (mode-str (cdr cleaner)))
             (when (eq mode major-mode)
               (setq mode-name mode-str)))))

(add-hook 'after-change-major-mode-hook 'rename-major-mode-line)
#+END_SRC


** COMMENT Cleanup the modeline --- minor modes
   :PROPERTIES:
   :header-args: :tangle no
   :END:

   Ref: [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Mode-Line-Data.html][The data structure of the modeline]]

   A lot of minor  modes show up in the modeline. It  would be nice to
   get rid of them. The package =diminish= allows to convert the minor
   mode indication. Notice  that I do not activate minor  modes in the
   doom-modeline.

#+BEGIN_SRC emacs-lisp
(use-package autorevert
     :config
     (diminish 'auto-revert-mode "")
     :commands auto-revert-mode)

(diminish 'auto-revert-mode)
(diminish 'auto-fill-function " ⓗ")
(diminish 'visual-line-mode  " ⓢ")
(diminish 'abbrev-mode "")
(diminish 'mml-mode "")
(diminish 'eldoc-mode "")
#+END_SRC


** COMMENT Cleanup the modeline --- syntax check with Flycheck
   :PROPERTIES:
   :header-args: :tangle no
   :END:

   This part is deactivated because of doom modeline.
   
   Flycheck spams the modeline. Let's try to make the error diagnostic
   more compact.
   
#+BEGIN_SRC emacs-lisp
(defun flycheck-mode-line-status-text-slim (&optional status)
  "Get a text describing STATUS for use in the mode line.

STATUS defaults to `flycheck-last-status-change' if omitted or
nil."
  (let ((text (pcase (or status flycheck-last-status-change)
                (`not-checked "")
                (`no-checker "")
                (`running "")
                (`errored "😵")
                (`finished
                 (let-alist (flycheck-count-errors flycheck-current-errors)
                   (if (or .error .warning .info)
                       (concat
                        "⎧"
                        (if .error (format "😱%s" .error ""))
                        (if .warning (format "😟%s" .warning ""))
                        (if .info (format "💁%s" .info ""))
                        "⎫"))))
                (`interrupted "😲")
                (`suspicious "😒"))))
    (concat " " text)))
#+END_SRC


* Prose and Technical Writing

  I   use  Emacs   to  write   technical  papers   about  math,   code
  documentation, lecture  notes for  my courses ,  blog posts,  and to
  edit   my    websites...   and   sometimes   to    prepare   slides.
  Therefore I  need to setup  a proper  environment. I often  see many
  emacs user writing  LaTeX with for a tool which  is barely setup for
  writing code, and definitely not right for writing prose.

  Emacs has  a lot of  potential in  prose writing, especially  if you
  ditch  LaTeX and  write  in Org  Mode or  Markdown.  In this  regard
  I suggest the following reading.

  - [[http://www.danielallington.net/2016/09/the-latex-fetish/][The LaTeX fetish (Or: Don’t write in LaTeX! It’s just for typesetting)]]
  - [[https://irreal.org/blog/?p=5054][Using Emacs for Prose]]

** Syntax and Grammar Check

   Too few  people on Emacs have  a decent setup for  syntax checking,
   and even  fewer have a decent  setup for grammar checking.  I don't
   claim that my setup is especially  clever, but at least it includes
   spell and grammar check in

   - Italian;
   - American English;
   - British English.

   In particular I  often write papers with colleagues  who prefer the
   British  spelling  rather  than   American  one  (which  I  favor),
   therefore I keep them both.

#+BEGIN_SRC emacs-lisp
(require 'ring)
(setq mxl-preferred-languages
      (ring-convert-sequence-to-ring '("british" "italiano" "english")))
#+END_SRC

   The entry points of my setup are three functionalities
   - Syntax/Grammar check, activated with =mxl-language-check=
   - Cycle between languages with =mxl-language-cycle=
   - Fix interactively the typos

#+BEGIN_SRC emacs-lisp
(global-set-key [f2]  'mxl-language-check)
(global-set-key (kbd "M-<f2>") 'mxl-language-cycle)
(global-set-key [M-s]  'ispell-word)
#+END_SRC

   The setup revolves on few  packages.

   - [[https://www.cs.hmc.edu/~geoff/ispell.html][Ispell]] (actually [[https://hunspell.github.io/][Hunspell]] ) for spell checking;
   - [[http://www-sop.inria.fr/members/Manuel.Serrano/flyspell/flyspell.html][Flyspell]] for spelling errors highlighting and fixing of typos;
   - [[https://languagetool.org/][LanguageTool]] and [[https://github.com/mhayashi1120/Emacs-langtool][langtool.el]] for grammar checking.

   Flyspell requires a working setup of  Ispell. I setup the latter to
   make  use  of  [[https://hunspell.github.io/][Hunspell]],  which  is  the  default  spellchecker  of
   Libre/Openoffice and Firefox.  Notice that I usually  need to place
   my  dictionaries   for  hunspell  in  a   non  standard  directory.
   Hunspell  look  them  in  the  directories  in  the  =DICPATH=  env
   variable. Be careful to have  dictionaries for all three languages,
   otherwise the setup will fail.

#+BEGIN_SRC emacs-lisp :tangle no
(setenv "DICPATH" (concat (getenv "HOME") "..."))
#+END_SRC

   Flyspell highlights typos  and strikes out words  that are repeated
   within a  certain distance =flyspell-duplicate-distance=,  which is
   set  to 0  because  I  only want  to  signal adjacent  repetitions.
   Notice that  I activate  flyspell using the  first of  my preferred
   languages,  and that  I use  =flyspell-prog-mode= for  programming.
   Flyspell  allows a  more  interactive interface  for fixing  typos,
   contrary to the default =ispell-word=.

#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :commands (flyspell-mode flyspell-prog-mode)
  :bind (:map flyspell-mode-map ("C-;" . nil))
  :config
  (setq flyspell-duplicate-distance 0     ;; signal as repetitions only adjacent pairs
        flyspell-highlight-flag t         ;; mark mispelled words
        flyspell-issue-message-flag nil   ;; silent checking
        flyspell-persistent-highlight nil ;; only highlight one word
        flyspell-use-meta-tab nil)
  (setq ispell-program-name (executable-find "hunspell"))
  (setq ispell-dictionary (ring-ref mxl-preferred-languages -1))  ;; last language by default
  (if (not ispell-program-name)
      (message "Spell checking disabled: impossible to find correctly installed 'Hunspell'.")))

(add-hook 'text-mode-hook 'flyspell-mode)
(add-hook 'prog-mode-hook 'flyspell-prog-mode)

(use-package flyspell-correct-helm
  :after flyspell
  :bind (:map flyspell-mode-map
              ("M-s" . flyspell-correct-wrapper)))
#+END_SRC

   The language  for spell and  grammar check is  the last one  in the
   ring  =mxl-preferred-languages=,  so  that  we  switch  the  chosen
   language by rotating the ring. Mode-line will signal which one that
   is.

#+BEGIN_SRC emacs-lisp
(defun mxl-set-flyspell-modeline ()
  "Refresh the flyspell modeline with language indicator"
  (interactive)
  (setq flyspell-mode-line-string
        (let ((lang (or ispell-local-dictionary ispell-dictionary nil)))
          (cond
           ((string-equal lang "italiano") " [it]")
           ((string-equal lang "english")  " [en]")
           ((string-equal lang "british")  " [gb]")
           (t "")))))

(defadvice ispell-init-process (after ispell-init-process-after activate)
  (mxl-set-flyspell-modeline))

#+END_SRC

   This is the code for cycling among the preferred languages. At each
   rotation the  settings for both  the spell checker and  the grammar
   checker are updated.

#+BEGIN_SRC emacs-lisp
(defun mxl-language-cycle ()
  "Switch between spell checking languages, in the current buffer."
  (interactive)
  (let* ((lang-ring mxl-preferred-languages)
         (lang (ring-ref lang-ring -1)))
        (ring-insert lang-ring lang)
        (ispell-change-dictionary lang)
        (setq langtool-default-language
              (cond
               ((string-equal lang "italiano") "it")
               ((string-equal lang "english")  "en")
               ((string-equal lang "british")  "en-GB")
               (t "")))))
#+END_SRC

    Grammar check with Langtool is  reasonably easy to setup. The only
    caveat is  that it need  to be  installed. When installed,  we use
    =langtool-disabled-rules=   to   deactivate  some   checks   (e.g.
    whitespaces) which generates too many false positives.

#+BEGIN_SRC emacs-lisp
(setq langtool-path '("/usr/local/share/languagetool" "/snap/languagetool/current/usr/bin"))
(setq langtool-language-tool-jar (concat (dolist (elt langtool-path value)
                                             (setq value (if (file-directory-p elt) elt)))
                                           "/languagetool-commandline.jar"))
(when (file-exists-p langtool-language-tool-jar)
  (use-package langtool
    :config
    (setq langtool-mother-tongue "it")'
    (setq langtool-disabled-rules "WHITESPACE_RULE")
    :commands (langtool-check langtool-check-buffer langtool-switch-default-language)))
#+END_SRC

    The  last component  is  a  single function  =mxl-language-check=.
    Allows to
    - pick between syntax and grammar check in the current language;
    - stop grammar check if one is running;
#+BEGIN_SRC emacs-lisp

;; Spell/Grammar check command
(defun mxl-language-check ()
  "Launch either spell check or grammar check

Offer a choice between spell checking the buffer, or grammar
checking it. It a region is active the spell check will be
performed on that region. If some grammar checking session is
open, the command will just close it.
"
  (interactive)
   ;; If grammar check is active, close it
  (if (and (boundp 'langtool-mode-line-message)
           langtool-mode-line-message)
      (langtool-check-done)
    ;; otherwise offer a choice
    (let* ((choices '("spelling" "grammar" "none"))
           (selection (ido-completing-read "Check for " choices )))
      (pcase selection
        ("spelling"
         (if (region-active-p)
             (call-interactively 'ispell-region)
           (ispell-buffer)))
        ("grammar" (langtool-check-buffer))
        (otherwise nil))
      )))
#+END_SRC



** Word wrapping and text width

   I  like  when  files  are,   to  some  extent,  of  limited  width.
   Unfortunately  it is  not  always possible  for technical  reasons.
   There are many options to wrap a text a specific width, either hard
   coding  newlines,  or wrapping  on  the  display without  modifying
   the file.

   - =auto-fill-mode=  (hard insert line breaks automatically)
   - =visual-fill-mode= (visual wrap at window margin)
   - =visual-fill-column-mode= (visual wrap at fixed margin)

   To be  readable, prose text files  should have at most  70 columns.
   And when word wrapping is hard-coded, the text should be justified.

#+BEGIN_SRC emacs-lisp
(setq fill-column 70)
(setq default-justification 'full)
(add-hook 'text-mode-hook 'turn-on-auto-fill)
#+END_SRC

   For  text  files  like  org-mode  files  it  is  better  to  enable
   =auto-fill-mode=. For email messages it  is better to use something
   like  =visual-fill-column-mode=.  The standard  =visual-line-mode=
   matches the text width with the  window width, which is annoying on
   large horizontal screen.

   Notice that it is  possible for =visual-fill-column-mode= to center
   the text setting =visual-fill-column-center-text= to =t=.

#+BEGIN_SRC emacs-lisp
(use-package visual-fill-column
  :disabled
  :init
  (setq-local fill-column 70)
  (setq visual-fill-column-center-text nil)
  :config
  (advice-add 'text-scale-adjust :after #'visual-fill-column-adjust)
  :hook ((visual-line-mode . turn-on-visual-fill-column-mode)
         (visual-line-mode . turn-off-auto-fill)
         (message-mode . visual-line-mode)))
#+END_SRC

Writing prose is  easier in a no-distraction setup.  What did Virginia
Woolf say? "A Room of One's Own".

#+BEGIN_SRC emacs-lisp
(use-package writeroom-mode
  :init
  (setq writeroom-bottom-divider-width 0))
#+END_SRC


** Math and Latex

*** Math mode is LaTeX/Org-mode

   My main  TeX/LaTeX setup  is based  on its own  file, but  there is
   a  nice utility  which allows  to conveniently  type the  depecated
   dollas  signs. By  typing  a dollar,  the inline  pair  =\( \)=  is
   inserted. It toogles between pair =\( \)= and =\[ \]= everytime the
   dollar is typed while at the end of a pair or inside an empty pair.

   Recall you can type =$= by preceding it with =C-q=.
   
#+BEGIN_SRC emacs-lisp
(use-package math-delimiters
  :commands (math-delimiters-insert)
  :ensure nil)

(with-eval-after-load 'org
  (define-key org-mode-map "$" #'math-delimiters-insert))

(with-eval-after-load 'tex              ; for AUCTeX
  (define-key TeX-mode-map "$" #'math-delimiters-insert))

(with-eval-after-load 'tex-mode         ; for the built-in TeX/LaTeX modes
  (define-key tex-mode-map "$" #'math-delimiters-insert))
#+END_SRC

#+RESULTS:
: math-delimiters-insert

   


* Org-Protocol integration

  Org-mode  provides a  protocol for  capturing snippets  of text  and
  informations, and to store links. In order to make this feature work
  under macOS it is necessary to install some script which manages the
  org-protocol at OS level. I have built such app according to

  - https://github.com/xuchunyang/setup-org-protocol-on-mac

  and   saved   it   into   the   =macos=   folder   in   this   emacs
  configuration repository. In order to make it work just copy it into
  =/Applications= folder.

* Programming


** Tab vs Space

   Of course I use 4 spaces for indentation

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil) ;; Expand tabs as spaces
(setq-default tab-width 4)
(setq default-tab-width 4)
#+END_SRC

   
** Trailing whitespaces
  
  Removal of trailing  whitespace is useful in code. I  would do it in
  text files  as well, but  working in  parallel on LaTeX  files makes
  such  removals problematic  with  co-authors. It  makes merges  more
  difficult.

  But in  code this is  not usually an  issue. So let's  set automatic
  deletion of trailing whitespace, but just in programming buffers.

#+BEGIN_SRC emacs-lisp
(defun mxl/delete-trailing-whitespace-on-save-on ()
  (interactive)
  (add-hook 'before-save-hook 'delete-trailing-whitespace 0 t))

(defun mxl/delete-trailing-whitespace-on-save-off ()
  (interactive)
  (remove-hook 'before-save-hook #'delete-trailing-whitespace t))

(add-hook 'prog-mode-hook #'mxl/delete-trailing-whitespace-on-save-on)
#+END_SRC

** Generic Syntax highlighting

   Of  course   every  mode   include  syntax  highlighting   for  the
   corresponding  type of  file.  There are  more  "semantic" ways  to
   highlight pieces of codes. Many  of these syntax highlight packages
   are described in

   - [[http://www.wilfred.me.uk/blog/2014/09/27/the-definitive-guide-to-syntax-highlighting/][The Definitive Guide To Syntax Highlighting]]

   The first package color parenthesis  with dirrerent colors, so that
   matching  parenthesis have  the same  color. Of  course after  some
   nesting  the   colors  repeat.   This  is  especially   useful  for
   lisp programming.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :diminish ""
  :init (setq rainbow-delimiters-max-face-count 4)
  :commands rainbow-delimiters-mode
  :hook ((emacs-lisp-mode . rainbow-delimiters-mode)
         (lisp-interaction-mode . rainbow-delimiters-mode)))
#+END_SRC

   The next package colors each identifier, so that the occurrences of
   that identifier have the same color than the definition.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-identifiers
  :diminish ""
  :commands rainbow-identifiers-mode)
#+END_SRC


   Next  package sets  a different  background color  for each  nested
   code block.

#+BEGIN_SRC emacs-lisp
(use-package highlight-blocks
  :diminish ""
  :commands highlight-blocks-mode)
#+END_SRC

   Next package highlights occurrences of the symbol under the point.

#+BEGIN_SRC emacs-lisp
(use-package highlight-symbol
  :diminish ""
  :commands highlight-symbol-mode)
#+END_SRC

   Next package highlight  lisp quotes, so it is not  useful for other
   languages (maybe Scheme?).

#+BEGIN_SRC emacs-lisp
(use-package highlight-quoted
  :diminish ""
  :commands highlight-quoted-mode)
#+END_SRC

  Next package is  useful for emacs lisp. It highlight  names that are
  defined  in   emacs  lisp,  differentiating   functions,  variables,
  builtins, ...

#+BEGIN_SRC emacs-lisp
(use-package  highlight-defined  :ensure t
  :commands highlight-defined-mode)
#+END_SRC

** Highlight notes in comment

   This  code  was stolen  by  Casey  Muratori  aka [[https://www.youtube.com/channel/UCaTznQhurW5AaiYPbhEA-KA][Molly  Rocket]]  and
   highlight some words in code to make annotations. I implement
   - TODO (Red)
   - NOTE (Green)
   - CITE (Blue)
   - ALERT (Yellow)
   - WARNING (YELLOW)

#+BEGIN_SRC emacs-lisp
(setq mxl-annotation-prog-modes
      '(python-mode
        c++-mode
        c-mode
        sh-mode
        emacs-lisp-mode))

(make-face 'font-lock-fixme-face)
(make-face 'font-lock-note-face)
(make-face 'font-lock-cite-face)
(make-face 'font-lock-alert-face)
(mapc (lambda (mode)
        (font-lock-add-keywords
         mode
         '(("\\<\\(TODO\\)" 1 'font-lock-fixme-face t)
	       ("\\<\\(NOTE\\)" 1 'font-lock-note-face t)
	       ("\\<\\(ALERT\\)" 1 'font-lock-alert-face t)
	       ("\\<\\(WARNING\\)" 1 'font-lock-alert-face t)
	       ("\\<\\(CITE\\)" 1 'font-lock-cite-face t))))
	  mxl-annotation-prog-modes)

(modify-face 'font-lock-fixme-face "Red" nil nil t nil nil nil nil)
(modify-face 'font-lock-note-face "Light Green" nil nil t nil nil nil nil)
(modify-face 'font-lock-cite-face "Light Blue" nil nil t nil nil nil nil)
(modify-face 'font-lock-alert-face "Yellow" nil nil t nil nil nil nil)
     #+END_SRC
     
   

** Fixing Errors

   We all know most of development time is spend looking for error and
   fixing them.  Here we up set  the basic function that  Emacs has to
   compile and navigate the  errors ~previous-error~ and ~next-error~.
   The function keys  from =F9= to =F12= are  reserved for development
   needs, and the functionality strongly  depends on the current mode.
   In particular I would like
   - =F9= run something;
   - =F10= debug/interact;
   - =F11= previous error;
   - =F12= next error.
   And I use =M-F11= and =M-F12= to  toggle the list errors. To do the
   latter we need to implement specific functions.

   First we fix some general keybindings.
   
#+BEGIN_SRC emacs-lisp
(global-set-key [f9]  'recompile)
(global-set-key (kbd "M-<f9>")  'compile)
(global-set-key [f10] 'gdb)
(global-set-key [f11] 'previous-error)
(global-set-key [f12] 'next-error)
#+END_SRC

In order to  toggle the visibility of  the error list I  have to write
specific  code. This  is annoying  and  moreover does  not cover  many
cases. Since  LaTeX error management  is a bit  special, I have  to do
a specific setup for that.

#+BEGIN_SRC emacs-lisp

(setq flycheck-navigation-minimum-level 'warning)
(setq flycheck-error-list-minimum-level 'warning)

(defun mxl/toggle-flycheck-errors (&optional buffer-or-name)
  "Toggle the visibility or the Flycheck error list.

The error list is the buffer that contains the errors which can
be navigated by `next-error' and `previous-error'. The function
visualizes the error
"
  (interactive)
  (let ((window (get-buffer-window "*Flycheck errors*")))
  (if window (progn
               (delete-window window)
               (eldoc-mode 1)
               (flycheck-mode -1))
    (eldoc-mode -1)
    (flycheck-mode 1)
    (flycheck-list-errors)
    (setq next-error-last-buffer (get-buffer "*Flycheck errors*"))
    )))


(defun mxl/toggle-flymake-errors()
  "Toggle the visibility or the Flycheck error list.

The error list is the buffer that contains the errors which can
be navigated by `flymake-next-error' and `flymake-previous-error'. The function
visualizes the error
"
  (interactive)
  (let ((buffer (get-buffer (flymake--diagnostics-buffer-name))))
    (if (and buffer (get-buffer-window buffer))
        (delete-windows-on buffer)
      (flymake-show-diagnostics-buffer))))
#+END_SRC

   Most programming languages are supported by =flycheck=, a tool that
   automatically   checks  the   buffer  for   error  while   writing.
   It =flycheck= activates in the  buffers to the supported languages,
   assuming  all   needed  tools   for  that  language   are  present.
   Use   =flycheck-verify-setup=    to   investigate    the   checkers
   enabled/disabled/available  in  a  buffer.  I don't  like  all  the
   annotations that flycheck leaves on the buffer. It makes everything
   more confused, therefore I activate flycheck only when I proctively
   show the list of errors explicitly.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :init
  (setq-default flycheck-disabled-checkers '(tex-chktex))
  (setq flycheck-display-errors-function #'flycheck-display-error-messages
        flycheck-highlighting-mode 'symbols
        flycheck-indication-mode nil
        flycheck-idle-change-delay 0.5)
  :config
  (defalias 'flycheck-mode-line-status-text 'flycheck-mode-line-status-text-slim)
  :bind
  (("<f11>" . previous-error)
   ("<f12>" . next-error)
   ("M-<f11>" . mxl/toggle-flycheck-errors)
   ("M-<f12>" . mxl/toggle-flycheck-errors)
   ))

(setq flycheck-global-modes '(not org-mode)) ; Use eglot/flymake 
#+END_SRC

For   some  language   I  use   [[https://github.com/joaotavora/eglot][Eglot]],  which   integrates  =flymake=.
Therefore I set some similar keybindings for it.

#+BEGIN_SRC emacs-lisp
(use-package flymake
  :bind (:map flymake-mode-map
              ("<f11>"   .  flymake-goto-prev-error)
              ("<f12>"   .  flymake-goto-next-error)
              ("M-<f11>" .  mxl/toggle-flymake-errors)
              ("M-<f12>" .  mxl/toggle-flymake-errors)))
#+END_SRC


** Inferior shell

   I like the inferior  shell to scroll to bottom when  I send code to
   be executed.
   
#+BEGIN_SRC emacs-lisp
(setq comint-scroll-to-bottom-on-input t)
(setq comint-scroll-to-bottom-on-output t)
(setq comint-move-point-for-output t)
#+END_SRC

** Programming language support (LSP)
   
   The most convenient way to  integrate language features nowadays is
   to  use a  language  server that  implements  LSP (Language  Server
   Protocol). I am currenly using  [[https://github.com/joaotavora/eglot][Eglot]] which should provide, and set
   up on its own, several features as
   - completion using =company-mode=
   - integrated help using =eldoc=
   - jump to/from definitions using =xref= (try =M-,= =M-.= keybindings)
   - code snippets (if =yasnippet= is enabled in advance)
   - code checking using =flymake= (I will disable it in favor of =flycheck=)
   - other features...
  
#+BEGIN_SRC emacs-lisp

(defun mxl/swap-syntaxchecker()
  (flymake-mode -1)
  (flycheck-mode 1))

(defun mxl/eglot-format-region-or-defun ()
  (interactive)
  (save-mark-and-excursion
    (if (not (region-active-p))
        (mark-defun))
    (call-interactively 'eglot-format)))


(use-package eglot
  :config
  (add-to-list 'eglot-stay-out-of 'flymake)
  (diminish 'eldoc-mode))
#+END_SRC

   
   [[https://github.com/joaotavora/eglot][Eglot]] detects the root of a project using =project-find-dir=, which
   by  default  considers  a  Git  submodule as  part  of  a  project.
   I usually  work in a different  way, and I consider  Git submodules
   are standalone.

#+BEGIN_SRC emacs-lisp
(setq project-vc-merge-submodules nil)
#+END_SRC

   With  this function  we  activate the  automatic formatting  before
   file saving. Not very quick for large files.

#+BEGIN_SRC emacs-lisp
(defun mxl/eglot-format-buffer-on-save ()
  (add-hook 'before-save-hook #'eglot-format-buffer -10 t))
#+END_SRC

   We configure basic keybindings for the modes that use =eglot=

** Python

   Python is the  programming language I am using  the most, nowadays.
   My setup is  not very sophisticated right now. Earlier  it was more
   complex  but  it  was  breaking  quite  often  at  each  change  of
   technology, Ipython, and so on...

   My configuration  is based around the  default =python.el= included
   with  Emacs   (there  are   indeed  other  python   modes  around).
   Furthermore it uses
   - =eglot= as a LSP client, providing help, completion, symbol search;
   - requires  to  run  ~pip  install  python-lsp-server~  to  install
     =pylsp=;
   - =pyenv= to manage the virtual environments.
   - standard  python   as  interactive  shell  (Ipython   prompt  and
     completion tend to confuse Emacs if not well configured).
   - =yapfify= to format code.

   Binaries will be found in the =pyenv= paths.

#+BEGIN_SRC emacs-lisp
(add-to-list 'exec-path (concat (getenv "HOME") "/.pyenv/shims"))
(add-to-list 'exec-path (concat (getenv "HOME") "/.pyenv/bin"))
(environment-add-path (concat (getenv "HOME") "/.pyenv/shims"))
(environment-add-path (concat (getenv "HOME") "/.pyenv/bin"))
#+END_SRC

We  set  the key  F9  to  launch the  tests  for  the python  program.
In particular we use  =python-pytest-dispatch=, which shows a complete
interface similar  to Magit,  and allows  various options  for testing
(i.e. test a single file/module).

#+BEGIN_SRC emacs-lisp
(use-package python-pytest
  :commands python-pytest-dispatch)
#+END_SRC

Using the  key F10 I can  toggle the prompt shell  buffer connected to
this python buffer.

By default  =C-c C-c=  uses =python-shell-send-buffer= which  does not
execute the content  of main by default. I usually  need it, therefore
I remap the key.

To format code  I use =yapfify=. I use this  custom function to either
format regions or function definitions.

#+BEGIN_SRC emacs-lisp
(defun mxl/yapfify-region-or-defun ()
  (interactive)
  (if (python-syntax-comment-or-string-p)
      (python-fill-paragraph t)
    (save-mark-and-excursion
      (if (not (region-active-p))
          (python-mark-defun))
      (call-interactively 'yapfify-region))))
#+END_SRC



#+BEGIN_SRC emacs-lisp
(use-package python
  :init
  (setq python-indent-guess-indent-offset nil
        python-indent-offset 4)
  :hook ((python-mode . eglot-ensure))
  :bind (:map python-mode-map
              ("M-q"     .  mxl/yapfify-region-or-defun)
              ("C-M-q"   .  yapfify-buffer)
              ("<f10>"   .  python-shell-switch-to-shell)
              ("<f9>"    .  python-pytest-repeat)
              ("<f10>"   .  python-shell-switch-to-shell)
              ("M-<f9>"  .  python-pytest-dispatch)
              ("M-<f10>" .  run-python)
              ;; Force the execution of the main block
              ("C-c C-c" .  (lambda () (interactive) (python-shell-send-buffer t)))
         :map inferior-python-mode-map
              ("<f10>" . delete-window)))
#+END_SRC


  I  have  not reached  a  definitive  configuration regarding  syntax
  checking. I used to run [[https://www.pylint.org/][Pylint]]  or [[https://flake8.pycqa.org/en/latest/][Flake8]] from by [[https://www.flycheck.org/][Flycheck]], an emacs
  package  which highlight  code errors.  Now I  use [[https://github.com/joaotavora/eglot][Eglot]]  which runs
  =flymake= by default, and provides =eglot-format= with calls [[https://github.com/google/yapf][Yapf]] to
  enforce  code  formatting. I  would  like  to run  it  automatically
  before saving.


  Emacs is able to find the appropriate =pyenv= Python Environment and
  to  load  it  automatically.  Which is  useful  for  running  syntax
  checkers or  the Python Shell.  Notice that by  default =pyenv-mode=
  sets key  bidings on =C-c C-s=  and =C-c C-u=, which  conflicts with
  tons  of  stuff,  including  =org-schedule=. Hence  I  disable  such
  bindings,  since  =pyenv-mode-auto=   sets  the  python  environment
  automatically according  =.python-version=. In the rare  cases where
  I  need  to  switch  environment  I usually  run  the  command  from
  the minibuffer.

#+BEGIN_SRC emacs-lisp
(use-package pyenv-mode
  :bind (:map pyenv-mode-map
         ("C-c C-s" . nil)
         ("C-c C-u" . nil))
  :commands (pyenv-mode-set pyenv-mode-unset pyenv-mode))

(use-package pyenv-mode-auto
  :hook (find-file . pyenv-mode-auto-hook)
  :config (pyenv-mode))
#+END_SRC

** C and C++

   Setup  C and  C++  modes, using  [[https://github.com/joaotavora/eglot][Eglot]] which  in  turn uses  =ccls=
   by default.

#+BEGIN_SRC emacs-lisp
(defun mxl/cc-mode-setup ()
  "Setup for C/C++ modes"
  (set-fill-column 78))

(use-package cc-mode
  :config
  (setq c-basic-offset 4)
  (setq c-block-comment-prefix "")
  :bind (:map c-mode-map 
         ("RET"     .  newline-and-indent)
         ("M-SPC"   .  ff-find-related-file)
         :map c++-mode-map 
         ("RET"     .  newline-and-indent)
         ("M-SPC"   .  ff-find-related-file))
  :hook ((c-mode    . eglot-ensure)
         (c++-mode  . eglot-ensure)
         (c-mode    . mxl/cc-mode-setup)
         (c++-mode  . mxl/cc-mode-setup)))
#+END_SRC

This  is  a simple  function  to  be  used  when writing  single  file
C/C++ code.

#+BEGIN_SRC emacs-lisp
(defun mxl/simplec-compileandrun()
  "Compile and run the current C/C++ file"
  (interactive)
  (save-buffer)
  (let* ((ext (file-name-extension (buffer-file-name)))
         (src (file-name-nondirectory (buffer-file-name)))
         (exe (file-name-sans-extension src))
         (flg "-ggdb"))
    (shell-command (pcase ext
               ("c"   (concat "gcc " flg " " src " -o " exe " && ./" exe))
               ("cc"  (concat "g++ " flg " " src " -o " exe " && ./" exe))
               ("cpp" (concat "g++ " flg " " src " -o " exe " && ./" exe))
               ("cxx" (concat "g++ " flg " " src " -o " exe " && ./" exe))
               ))))
#+END_SRC


** Emacs Lisp

   Emacs  lisp is  pretty integrated  in Emacs,  dah! Nevertheless  in
   order   to  navigate   in  symbols,   it  is   better  to   install
   =elisp-slime-nav-mode=.

#+BEGIN_SRC emacs-lisp
(use-package elisp-slime-nav
  :diminish ""
  :hook ((lisp-interaction-mode . elisp-slime-nav-mode)
         (emacs-lisp-mode . elisp-slime-nav-mode)
         (ielm-mode . elisp-slime-nav-mode)))
#+END_SRC

   It is nice  to have documentation for  the stuff we do  and read in
   elisp code. So it is a good idea to turn on =eldoc= if possible.

#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
(add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
(add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)
#+END_SRC

** Shell programming

   I don't  have a  particularly clever  setup for  shell programming,
   even though  I should probably  take it more seriously.  There many
   bad  patterns in  shell programming  and  few good  ones. I  should
   massively use  snippets. One  thing that is  needed is  to activate
   shell mode automatically for [[http://zsh.sourceforge.net/][Zsh]] scripts.

   I don't know  muc shell programming. Maybe I  should make templates
   for good bash programming practices as in
   - [[http://mywiki.wooledge.org/BashPitfalls][Bash Pitfalls]]
   - [[http://redsymbol.net/articles/unofficial-bash-strict-mode/][Bash Strict mode]]

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.zsh" . sh-mode))
#+END_SRC

   Furthermore   it  is   possible   to  edit   command  lines   while
   using terminal. This setup activates ~sh-mode~ there as well

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("zsh[a-zA-Z0-9]*" . sh-mode))
(add-to-list 'auto-mode-alist '("bash-fc-[0-9]*"  . sh-mode))
#+END_SRC

   There  is   a  nice   syntax  checker   for  shell   script  called
   =shellcheck=,  which  is  a  godsend  considering  how  brittle  is
   the language. One day I will set it up.

** Copyright notice and timestamps

   Automatic  update  of  the   copyright  notices  and  time  stamps.
   Useful to keep additional track  about files age, regardless of git
   history.

#+BEGIN_SRC emacs-lisp
(setq copyright-query nil)                       ; do not ask before a copyright
(add-hook 'before-save-hook 'copyright-update)   ; update copyright if present
(add-hook 'before-save-hook 'time-stamp)         ; insert timestamp
#+END_SRC

** Set compile command

It is possible to set the compile  command for a file via a file local
variable on top.

#+begin_example
/* -*- mode: C++; compile-command: "g++ -s -O3 code07.cc -o code07; ./code07" -*- */

// Get the data
#include <iostream>
#include <sstream>
#include <fstream>
.....
.....
#+end_example

In order not to make Emacs  complain, we declate compile-command to be
a safe variable.

#+BEGIN_SRC emacs-lisp
(put 'compile-command 'safe-local-variable #'stringp)
#+END_SRC



* Math packages

  I don't use math packages often,  and I should probably use them way
  more. Anyway  there is some  support for them  in Emacs, so  why not
  having a basic setup?

  Mathematica, Octave  and Matlab all  use files with  =.m= extension,
  which is the same extension of Objective-C files. Since I do not use
  either much, I don't need to fiddle with =auto-mode-alist=.

** Matlab

   There is =run-octave= so I guess =run=matlab= should exists.

#+BEGIN_SRC emacs-lisp
(use-package matlab
  :init
  (setq matlab-shell-command
        (or
         (executable-find "matlab")
         (executable-find "/usr/local/bin/matlab")
         (executable-find "/Applications/Matlab.app/bin/matlab")))
  (setq matlab-indent-function-body t)
  :commands (matlab-mode matlab-shell))


(defalias 'run-matlab 'matlab-shell)
#+END_SRC


** Mathematica

   Nowadays Mathematica  is a  super-cool software  that works  on the
   network  and has  great AI.  I guess  it is  nicer to  use via  the
   appropriate GUI or on the web. Still, emacs rocks.

#+BEGIN_SRC emacs-lisp
(use-package wolfram-mode
  :init
  (setq wolfram-program
      (or
       (executable-find "math")
       (executable-find "/usr/local/bin/math")
       (executable-find "/Applications/Mathematica.app/Contents/MacOS/MathKernel")))
  :commands (run-wolfram wolfram-mode))

(defalias 'run-mathematica 'run-wolfram)
#+END_SRC



* Reading Material

** Books

I manage books via  [[https://calibre-ebook.com/][Calibre]], which I use to store  and manage my PDFs,
Ebook, and so on. The package  [[https://github.com/chenyanming/calibredb.el][calibredb]] allows to access and open the
books from inside Emacs.

#+BEGIN_SRC emacs-lisp
(use-package calibredb
  :commands (calibredb calibredb-find-helm)
  :init
  (setq calibredb-id-width 5)
  (setq calibredb-format-all-the-icons nil)
  (setq calibredb-format-character-icons nil)
  :config
  (setq calibredb-root-dir (expand-file-name "~/cloud/Books/"))
  (setq calibredb-db-dir (concat calibredb-root-dir "/metadata.db")))
#+END_SRC

* Writing facilities

  I am not very happy with this  setup, but it fits with the fact that
  I  don't like  completion  and  snippet expansion  to  step on  each
  other  toes.  And  let's  admit  it,  =company-yasnippet=  does  not
  integrate at all with ~company-mode~.

  In general completion should only be  about stuff I am typing, while
  templates and  snippets should  trigger only when  explicitly asked.
  In  my configuration  templates (actually  snippets) all  start with
  characters ='<'=  followed by some text.  This is unlikely to  be in
  the   text   by   accident.   For    this   reason   I   don't   use
  =yasnippet-snippets= because it fills  by typing space with snippets
  which trigger out of the blue.
  
** Completion

   I like  to move in  the completion menu  using the =M-i=  and =M-k=
   keys.  =TAB=,  =M-o= and  =Enter=  do  completion, and  =M-l=  only
   expands the common part. =M-j= simply kills the previoius word.
   
#+BEGIN_SRC emacs-lisp
(use-package company
  :diminish t
  :config
  (setq company-dabbrev-downcase nil)
  :bind (:map company-active-map
              ("M-j" . backward-kill-word)
              ("M-l" . company-complete-selection)
              ("M-i" . company-select-previous)
              ("M-k" . company-select-next)
              ("M-u" . company-abort)
              ("M-o" . company-complete-common)
              ("\r" . nil)
              ([return] . nil)
              ("\t" . company-complete-selection)
              ([tab] . company-complete-selection)
              ))
#+END_SRC

   Completion is active by default.
   
#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook 'global-company-mode)
#+END_SRC

** Templates - Setup of Yasnippet.el

   I  use Yasnippet  both for  code  snippets and  for file  template.
   Previously I  set up Yasnippet so  that it would insert  a template
   for new files. It would not work  well for LaTeX files since I need
   many  types of  templates for  them, and  in general  whenever some
   tools  would   create  new   empty  files.   I  trigger   the  file
   template explicitly.

   I  do  not use  =yasnippet-snippets=.  I  only  use my  own  sparse
   collection of  snippets (some copied  and edited from  that package
   anyway).

#+BEGIN_SRC emacs-lisp
(setq mxl-local-snippet-dir (concat base-config-path "snippets/"))
#+END_SRC

   Basic setup of Yasnippet.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :commands (yas-minor-mode yas-global-mode yas-expand)
  :diminish (yas-minor-mode . "")

  ;; edit the snippets
  :mode  ("\\.yasnippet" . snippet-mode)
  :mode  ("\\.snippet" . snippet-mode)

  :init
  (add-to-list 'warning-suppress-types '(yasnippet backquote-change))
  (yas-global-mode 1)

  :config
  (setq yas-snippet-dirs (list mxl-local-snippet-dir))
  (setq yas-indent-line 'fixed)
  (progn
    (yas-reload-all)))
#+END_SRC

   We need to be careful about whitespace, while editing snippet specs.
   
#+BEGIN_SRC emacs-lisp
(add-hook 'snippet-mode-hook (lambda ()
                               (whitespace-mode)
                               (make-local-variable 'require-final-newline)
                               (setq require-final-newline nil)
                               ))
#+END_SRC

** Choice and expansion of templates (menu)

   There are two access point to templates/snippets.

   1. One  is by expanding  a template chosen from  a menu. I  map the
      menu   to  =M-t=   keybind,  since   I've  never   used  it   to
      transpose words.

#+BEGIN_SRC emacs-lisp
(use-package helm-c-yasnippet
  ;; M-t is usually reserved to transpose words, but I've never
  ;; used it.
  :init
  (setq helm-yas-space-match-any-greedy t
        helm-yas-display-key-on-candidate t)
  :bind ( "M-t" . helm-yas-complete))
#+END_SRC

   2. By expanding  during typing. All my snippets either  do not have
      a  key, hence  are accessible  only from  the menu,  or the  key
      starts with ='<'= .
   
* Other features
** Backup and autosave of files


   Emacs  manages  multiple  backups  for files,  and  furthermore  it
   remembers to  save stuff from time  to time. I'd rather  put all my
   backups and autosaves in a specific folder.

#+BEGIN_SRC emacs-lisp
(defvar mxl-autosave-dir "~/.emacs.d/autosaves/")
(defvar mxl-backup-dir   "~/.emacs.d/backups/")
(make-directory mxl-autosave-dir t)
(make-directory mxl-backup-dir t)
#+END_SRC


   First I setup the autosave feature

#+BEGIN_SRC emacs-lisp
(setq tramp-auto-save-directory mxl-autosave-dir)
(setq auto-save-file-name-transforms
      `((".*" ,mxl-autosave-dir t)))
#+END_SRC

   then I setup the backup features, where copies of old versions are
   kept. Disable backups for remote files.

#+BEGIN_SRC emacs-lisp
(setq make-backup-files t)

(setq version-control nil)

(setq delete-old-versions t) ;; silently delete old versions
(setq kept-new-versions 3)   ;; number of newest versions to keep
(setq kept-old-versions 2)   ;; number of oldest versions to keep
(setq backup-by-copying t)
(setq backup-by-copying-when-linked t)

(setq backup-directory-alist
      `(("." . ,mxl-backup-dir)                ;; location for local files
        (,tramp-file-name-regexp .  nil)))     ;; disable for remote files

#+END_SRC

** Bookmarks
   
   If you are  like me you have  several files you visit  on a regular
   bases,  for some  periods of  time. E.g.,  lecture folders,  course
   journal, the tex files for the  paper you are currently working on.
   It is convenient to bookmark  such locations, but the bookmark file
   should be in some private versioned folder.

#+BEGIN_SRC emacs-lisp
   (setq bookmark-default-file "~/personal/conf/emacs.bookmarks")
#+END_SRC

   I use =helm-mini=  to access and set bookmarks, but  it is possible
   to edit  and delete them with  command =bookmark-bmenu-list=, bound
   to =C-x r l=.

#+BEGIN_SRC emacs-lisp
(setq helm-mini-default-sources '(helm-source-buffers-list
                                  helm-source-recentf
                                  helm-source-bookmarks
                                  helm-source-buffer-not-found))
#+END_SRC

   The  list  of  recent  files  is  saved  on  Emacs  exit  and  kill
   by default. To err on safety, let's write the file 
   
#+BEGIN_SRC emacs-lisp
(use-package recentf
    :demand t
    :config
    (recentf-mode 1)
    (run-at-time nil (* 60 60) 'recentf-save-list))
#+END_SRC

** Hide some buffers in Helm
   
   Some buffers  clutter selection menus  and there are no  reasons to
   visit them.  For example the  buffer =*import calendar*=  just runs
   the  script   which  imports  my  google   calendars  in  org-mode.
   Better hide them from the buffer list.

#+BEGIN_SRC emacs-lisp
(setq helm-boring-buffer-regexp-list
  '("\\` " "\\`\\*helm" "\\`\\*Echo Area" "\\`\\*Minibuf" "\\`\\*Echo Area"
    "\\`\\*import calendar*"
    "\\`\\*Help"
    "\\`\\*Disabled Command"
    "\\`\\*Backtrace"))

(setq helm-white-buffer-regexp-list nil)

#+END_SRC

** Regexp search/replace

   Calling =replace= and =query-replace= on regexp(s) is quite tricky.
   It is difficult to understand  what the matched text is, especially
   when   using  the   emacs   regexp   syntax.  The   =visual-regexp=
   package helps.
   
#+BEGIN_SRC emacs-lisp
(use-package visual-regexp
  :commands (vr/replace vr/mc-mark vr/query-replace)
  :bind
  (("M-%" . vr/replace)
   ("C-M-%" . vr/query-replace)
  ))
#+END_SRC

** Setup regexp builder

#+BEGIN_SRC emacs-lisp
(use-package re-builder
  :init
  (setq reb-re-syntax 'string)
  )
#+END_SRC
