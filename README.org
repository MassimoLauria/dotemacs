# -*- coding: utf-8 -*-
#+STARTUP: collapsed
#+title: Massimo's Emacs configuration
#+author: Massimo Lauria <lauria.massimo@gmail.com>


This is the Emacs config of Massimo Lauria (C) 2009-2019.

This configuration  is under massive  and continue change,  and things
break every day. I just put it  online so you can cut & paste whatever
you may find useful.

This configuration assume a modern  Emacs installation (>=24). If your
Emacs  is less  recent than  that,  the configuration  will revert  to
a minimal version.

*Literate configuration*: this Emacs configuration is on the way to be
a /literate configuration/  developed as an =org-mode=  file. The plan
is that the very  document you are reading right now  will be the main
part of the  configuration itself. At this point this  is not true but
I am  putting in place the  infrastructure for it. I  will slowly move
part of the main config inside this =README.org= file.

* Bootstrapping the setup

  The   variable  =base-config-path=   keeps   the   path  where   the
  configuration is  installed. I add  that to the =load-path=,  and we
  also add the path of 3rd parties packages, which are packages I keep
  in the repository because they are not on =melpa= (yet).

#+BEGIN_SRC emacs-lisp
(setq 3rdparties-packages-path (concat base-config-path "3rdparties/"))

(add-to-list 'load-path base-config-path)
(add-to-list 'load-path 3rdparties-packages-path)
#+END_SRC

  I have local  info files, for example  "Structure and Interpretation
  of Computer Programs".
 
#+BEGIN_SRC emacs-lisp
(add-to-list 'Info-directory-list (concat base-config-path "/info"))
#+END_SRC
 
** Adjust =PATH= environment variables 
  
   When Emacs is  lauched as an app  (on MacOSX) or from  a gui command
   (in linux)  there is often  the chance that the  running environment
   does not contain some environment variables  or does not set them up
   appropriately. These  functions allow me  to care of such  issues as
   long as they arise in my setup. I don't claim any generality here.

   First  I have  two functions  to manage  variables for  the runtime
   environment where Emacs has been executed from.

#+BEGIN_SRC emacs-lisp
(defun environment-variable-add-to-list (varname element &optional append)
  "Add ELEMENT from the list in the enviroment variable VARNAME.

VARNAME is considered as a list of elements like \"aa:bb:cc\". If
VARNAME is undefined of empty, it defines it. If ELEMENT is
already in the list, the function won't do anything.

There is no guarantee on the actual order of the elements in the
list."  
  (let ((separator (if (eq system-type 'windows-nt) ";" ":"))
        tmplist)
    (if (getenv varname)
        (setq tmplist (split-string 
                       (getenv varname) 
                       separator)))
    (add-to-list 'tmplist element append 'string-equal)
    (setenv varname (mapconcat 'identity tmplist ":"))))

(defun environment-variable-rm-from-list (varname element)
  "Remove ELEMENT from the list in the enviroment variable VARNAME.

VARNAME is considered as a list of elements like \"aa:bb:cc\". If
ELEMENT is not in the list, the function won't do anything.

There is no guarantee on the actual order of the elements in the
list."  
  (let ((separator (if (eq system-type 'windows-nt) ";" ":"))
        tmplist)
    (if (getenv varname)
        (setq tmplist (split-string 
                       (getenv varname)
                       separator)))
    (setenv varname (mapconcat 'identity (remove element tmplist) ":"))))


#+END_SRC

   I use this functions primarily to fix =PATH=.

#+BEGIN_SRC emacs-lisp
(defun environment-add-path (newpath &optional append)
  "Add NEWPATH to the PATH environment variable and to exec-path,

Ignore if the path does not exists."
  (when (file-directory-p newpath)
    (add-to-list 'exec-path newpath append 'string-equal)
    (environment-variable-add-to-list "PATH" newpath append)))
#+END_SRC

   Some useful  paths to add  to the environment. In  particular tools
   like =Cask=,  =cabal=, =cargo=, install their  executables files in
   a corresponding hidden folder inside =$HOME=. 

#+BEGIN_SRC emacs-lisp
(environment-add-path "/usr/local/bin")                        ;; Homebrew  (MacOS)
(environment-add-path (concat (getenv "HOME") "/.cask/bin"))   ;; Cask      (for Elisp)
(environment-add-path (concat (getenv "HOME") "/.local/bin"))  ;; Local/bin (GNU/Linux)
#+END_SRC


  Actually the  right way to set  system-wide exec-paths on Mac  is to
  use `/etc/paths.d' files. I pick up these paths as well.

#+BEGIN_SRC emacs-lisp
(with-temp-buffer 
  (condition-case nil 
      (dolist (file (cons "/etc/paths" (directory-files "/etc/paths.d/" t)))
        (if (not (file-directory-p file))
            (insert-file-contents file)))
    (error nil))
      
  (dolist (path (split-string (buffer-string) "\n" t))
    (if (file-directory-p path)
        (environment-add-path path))))
#+END_SRC



** Private configuration

   A part  of the  setup is not  for the public  eye therefore  is not
   included in this repository. I  keep it in another position (inside
   a private =git= repository).

#+BEGIN_SRC emacs-lisp
(let ((private "~/personal/conf/emacs.el"))
  (when (file-readable-p private)
    (load-file private)))

#+END_SRC


* Localization/Internationalization
  
** Text encoding is always UTF-8

   I work  mostly with UTF-8 file,  Hence UTF-8 is the  default coding
   for buffers.

#+BEGIN_SRC emacs-lisp
(prefer-coding-system       'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(setq default-buffer-file-coding-system 'utf-8)
#+END_SRC

   The same setting seems to be needed for the clipboard.

#+BEGIN_SRC emacs-lisp
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
(set-clipboard-coding-system 'utf-8)
#+END_SRC

   I often need to write greek or  math symbols (e.g. α, ⊕), and since
   I know LaTeX it is convenient to use the same markup to insert them
   in regular text. Nevertheless it is inconvenient to have that on by
   default.    I    activate    it   when    needed    typing    =C-\=
   (=toggle-input-method=).

#+BEGIN_SRC emacs-lisp
(setq default-input-method 'TeX)
(set-input-method nil)
#+END_SRC


** Italians holidays, timezones and calendar names

   For  me it  is  useful to  have  the agenda  to  remind of  italian
   holidays,  especially   if  they  corresponds  to   vacation  days.
   I actually override the original  values of these variables because
   I don't care to know about holidays that do not affect me.

#+BEGIN_SRC emacs-lisp

;; Non-religious holidays
(setq holiday-general-holidays
      '((holiday-fixed 1 1 "Capodanno")
        (holiday-fixed 5 1 "Festa dei Lavoratori")
        (holiday-fixed 4 25 "Liberazione dal Nazifascismo")
        (holiday-fixed 6 2 "Festa della Repubblica")))

;; Catholics holidays that induce vacations
(setq holiday-christian-holidays
     '((holiday-fixed 12 8 "Immacolata Concezione")
       (holiday-fixed 12 25 "Natale")
       (holiday-fixed 12 26 "Santo Stefano")
       (holiday-fixed 1 6 "Epifania")
       (holiday-easter-etc -52 "Giovedì grasso")
       (holiday-easter-etc -47 "Martedì grasso")
       (holiday-easter-etc   0 "Pasqua")
       (holiday-easter-etc  +1 "Pasquetta")
       (holiday-fixed 8 15 "Ferragosto")
       (holiday-fixed 11 1 "Ognissanti")))

;; No other religious holidays induce vacation days in Italy.
(setq holiday-bahai-holidays nil)
(setq holiday-hebrew-holidays nil)
(setq holiday-islamic-holidays nil)
#+END_SRC

   In  Italy the  weekly  calendar  starts from  Monday,  hence I  set
   =calendar-week-start-day= accordingly. It is  also nice to have the
   names of months and weekdays translated.

#+BEGIN_SRC emacs-lisp
(setq calendar-week-start-day 1
      calendar-day-name-array ["Domenica" "Lunedì" "Martedì" "Mercoledì"
                               "Giovedì" "Venerdì" "Sabato"]
      calendar-month-name-array ["Gennaio" "Febbraio" "Marzo" "Aprile" "Maggio"
                                 "Giugno" "Luglio" "Agosto" "Settembre"
                                 "Ottobre" "Novembre" "Dicembre"])
#+END_SRC

   Several packages (e.g.  Org-mode) need to recognize  what a weekday
   name  or  a  month  name is.  Package  =parse-time=  provides  this
   functionality, but it only knows about English words. I can add the
   Italian ones to  ~parse-time-weekdays~ and ~parse-time-months~ when
   package =parse-time= is loaded. I also add the timezones.
 
#+BEGIN_SRC emacs-lisp :tangle no
(defconst parse-time-weekdays
  '(("dom" . 0) ("lun" . 1) ("mar" . 2) ("mer" . 3) ("gio" . 4) ("ven" . 5) ("sab" . 6)
    ("domenica" . 0) ("lunedì" .  1) ("martedì" . 2) ("mercoledì" . 3)
    ("giovedì" .  4) ("venerdì" . 5) ("sabato" .  6))
  "Italian weekdays to add to `parse-time-weekdays'.")


(defconst parse-time-months-ita
  '(("gen" . 1) ("feb" . 2) ("mar" . 3) ("apr" .  4) ("mag" .  5) ("giu" .  6)
    ("lug" . 7) ("ago" . 8) ("set" . 9) ("ott" . 10) ("nov" . 11) ("dic" . 12)
    ("gennaio" . 1)   ("febbraio" . 2) ("marzo" . 3)     ("aprile" . 4)
    ("maggio" . 5)    ("giugno" . 6)   ("luglio" . 7)    ("agosto" . 8)
    ("settembre" . 9) ("ottobre" . 10) ("novembre" . 11) ("dicembre" . 12))
  "Italian manths to add to `parse-time-months'.")

(use-package parse-time
  :config
  (setq parse-time-months   (append parse-time-months parse-time-months-ita))
  (setq parse-time-weekdays (append parse-time-weekdays parse-time-weekdays-ita))
  (add-to-list 'parse-time-zoneinfo  '("cet" 3600 t) t)  ;; Central European Time
  (add-to-list 'parse-time-zoneinfo  '("cest" 7200)  t)  ;; Central European Summer Time
  )
#+END_SRC




* Programming

** Syntax highlighting

   Of  course   every  mode   include  syntax  highlighting   for  the
   corresponding  type of  file.  There are  more  "semantic" ways  to
   highlight pieces of codes. Many of these syntax highlight packages are described in
   
   - [[http://www.wilfred.me.uk/blog/2014/09/27/the-definitive-guide-to-syntax-highlighting/][The Definitive Guide To Syntax Highlighting]]


   The first package color parenthesis  with dirrerent colors, so that
   matching  parenthesis have  the same  color. Of  course after  some
   nesting the colors repeat.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :init (setq rainbow-delimiters-max-face-count 4)
  :commands rainbow-delimiters-mode)
#+END_SRC
 
   The next package colors each identifier, so that the occurrences of
   that identifier have the same color than the definition.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-identifiers
  :commands rainbow-identifiers-mode)
#+END_SRC




* Math packages

  I don't use very often math packages, and I should probably use them
  way more. Anyway there is some support for them in Emacs, so why not
  having a basic setup?

  Interestingly enough  Mathematica, Octave  and Matlab all  use files
  with  =.m= extension,  which is  the same  extension of  Objective-C
  files. Well I do not use either very much, so I don't need to fiddle
  with =auto-mode-alist=.

** Matlab

   There is =run-octave= so I guess =run=matlab= should exists.
 
#+BEGIN_SRC emacs-lisp
(use-package matlab
  :init
  (setq matlab-shell-command
        (or
         (executable-find "matlab")
         (executable-find "/usr/local/bin/matlab")
         (executable-find "/Applications/Matlab.app/bin/matlab")))
  (setq matlab-indent-function-body t)
  :commands (matlab-mode matlab-shell))


(defalias 'run-matlab 'matlab-shell)
#+END_SRC
   

** Mathematica

   Nowadays Mathematica is a super-cool  packages that works mostly on
   the network  and has  great AI. I  guess it is  nicer when  used on
   the web.

#+BEGIN_SRC emacs-lisp
(use-package wolfram-mode
  :init
  (setq wolfram-program
      (or
       (executable-find "math")
       (executable-find "/usr/local/bin/math")
       (executable-find "/Applications/Mathematica.app/Contents/MacOS/MathKernel")))
  :commands (run-wolfram wolfram-mode))

(defalias 'run-mathematica 'run-wolfram)
#+END_SRC

   
