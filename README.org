#+title: Massimo's Emacs configuration
#+author: Massimo Lauria <massimo.lauria@uniroma1.it>
#+STARTUP: collapsed


This is the Emacs config of Massimo Lauria (C) 2009-2020.

This configuration  is under massive  and continue change,  and things
break every day. I just put it  online so you can cut & paste whatever
you may find useful.

This configuration assume a modern  Emacs installation (>=24). If your
Emacs  is less  recent than  that,  the configuration  will revert  to
a minimal version.

*Literate configuration*: this Emacs configuration is on the way to be
a /literate configuration/  developed as an =org-mode=  file. The plan
is that the very  document you are reading right now  will be the main
part of the  configuration itself. At this point this  is not true but
I am  putting in place the  infrastructure for it. I  will slowly move
part of the main config inside this =README.org= file.

* Bootstrapping the setup

  The   variable  =base-config-path=   keeps   the   path  where   the
  configuration is  installed. I add  that to the =load-path=,  and we
  also add the path of 3rd parties packages, which are packages I keep
  in the repository because they are not on =melpa= (yet).

#+BEGIN_SRC emacs-lisp
(setq 3rdparties-packages-path (concat base-config-path "3rdparties/"))

(add-to-list 'load-path base-config-path)
(add-to-list 'load-path 3rdparties-packages-path)
#+END_SRC

  The best way to  read Info files is in emacs.  The client merges all
  info /dir/  files in  a single index.  Therefore among  other things
  I  make  the  index  to  show  my  local  info  documents  as  well.
  For example  my copy  of "Structure  and Interpretation  of Computer
  Programs".

#+BEGIN_SRC emacs-lisp
(if (not (boundp 'Info-directory-list))
    (setq Info-directory-list nil))
(add-to-list 'Info-directory-list (concat base-config-path "/info"))
#+END_SRC

** Adjust =PATH= environment variables

   When Emacs is  lauched as an app  (on MacOSX) or from  a gui command
   (in linux)  there is often  the chance that the  running environment
   does not contain some environment variables  or does not set them up
   appropriately. These  functions allow me  to care of such  issues as
   long as they arise in my setup. I don't claim any generality here.

   First  I have  two functions  to manage  variables for  the runtime
   environment where Emacs has been executed from.

#+BEGIN_SRC emacs-lisp
(defun environment-variable-add-to-list (varname element &optional append)
  "Add ELEMENT from the list in the enviroment variable VARNAME.

VARNAME is considered as a list of elements like \"aa:bb:cc\". If
VARNAME is undefined of empty, it defines it. If ELEMENT is
already in the list, the function won't do anything.

There is no guarantee on the actual order of the elements in the
list."
  (let ((separator (if (eq system-type 'windows-nt) ";" ":"))
        tmplist)
    (if (getenv varname)
        (setq tmplist (split-string
                       (getenv varname)
                       separator)))
    (add-to-list 'tmplist element append 'string-equal)
    (setenv varname (mapconcat 'identity tmplist ":"))))

(defun environment-variable-rm-from-list (varname element)
  "Remove ELEMENT from the list in the enviroment variable VARNAME.

VARNAME is considered as a list of elements like \"aa:bb:cc\". If
ELEMENT is not in the list, the function won't do anything.

There is no guarantee on the actual order of the elements in the
list."
  (let ((separator (if (eq system-type 'windows-nt) ";" ":"))
        tmplist)
    (if (getenv varname)
        (setq tmplist (split-string
                       (getenv varname)
                       separator)))
    (setenv varname (mapconcat 'identity (remove element tmplist) ":"))))


#+END_SRC

   I use this functions primarily to fix =PATH=.

#+BEGIN_SRC emacs-lisp
(defun environment-add-path (newpath &optional append)
  "Add NEWPATH to the PATH environment variable and to exec-path,

Ignore if the path does not exists."
  (when (file-directory-p newpath)
    (add-to-list 'exec-path newpath append 'string-equal)
    (environment-variable-add-to-list "PATH" newpath append)))
#+END_SRC

   Some useful  paths to add  to the environment. In  particular tools
   like =Cask=,  =cabal=, =cargo=, install their  executables files in
   a corresponding hidden folder inside =$HOME=.

#+BEGIN_SRC emacs-lisp
(environment-add-path "/usr/local/bin")                        ;; Homebrew  (MacOS)
(environment-add-path (concat (getenv "HOME") "/.cask/bin"))   ;; Cask      (for Elisp)
(environment-add-path (concat (getenv "HOME") "/.local/bin"))  ;; Local/bin (GNU/Linux)
#+END_SRC


  Actually the  right way to set  system-wide exec-paths on Mac  is to
  use `/etc/paths.d' files. I pick up these paths as well.

#+BEGIN_SRC emacs-lisp
(with-temp-buffer
  (condition-case nil
      (dolist (file (cons "/etc/paths" (directory-files "/etc/paths.d/" t)))
        (if (not (file-directory-p file))
            (insert-file-contents file)))
    (error nil))

  (dolist (path (split-string (buffer-string) "\n" t))
    (if (file-directory-p path)
        (environment-add-path path))))
#+END_SRC



** Private configuration

   Part of my setup  is not for the public eye and  is not included in
   the repository.

#+BEGIN_SRC emacs-lisp
(let ((private "~/personal/conf/emacs.el"))
  (when (file-readable-p private)
    (load-file private)))
#+END_SRC


* Localization/Internationalization

#+BEGIN_SRC emacs-lisp
(setenv "LANG" "it_IT.UTF-8")
#+END_SRC


** Text encoding is always UTF-8

   I work  mostly with UTF-8 file,  Hence UTF-8 is the  default coding
   for buffers.

#+BEGIN_SRC emacs-lisp
(prefer-coding-system       'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(setq default-buffer-file-coding-system 'utf-8)
#+END_SRC

   The same setting seems to be needed for the clipboard.

#+BEGIN_SRC emacs-lisp
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
(set-clipboard-coding-system 'utf-8)
#+END_SRC

   I often need to write greek or  math symbols (e.g. α, ⊕), and since
   I know LaTeX it is convenient to use the same markup to insert them
   in regular text. Nevertheless it is inconvenient to have that on by
   default.    I    activate    it   when    needed    typing    =C-\=
   (=toggle-input-method=).

#+BEGIN_SRC emacs-lisp
(setq default-input-method 'TeX)
(set-input-method nil)
#+END_SRC


** Italians holidays, timezones and calendar names

   For  me it  is  useful to  have  the agenda  to  remind of  italian
   holidays,  especially   if  they  corresponds  to   vacation  days.
   I override the  original values of these variables  because I don't
   care to know about holidays that do not affect me.

#+BEGIN_SRC emacs-lisp

;; Non-religious holidays
(setq holiday-general-holidays
      '((holiday-fixed 1 1 "Capodanno")
        (holiday-fixed 3 8 "Giornata internazionale della donna")
        (holiday-fixed 5 1 "Festa dei Lavoratori")
        (holiday-fixed 4 25 "Liberazione dal Nazifascismo")
        (holiday-fixed 6 2 "Festa della Repubblica")))

;; Catholics holidays that induce vacations
(setq holiday-christian-holidays
     '((holiday-fixed 12 8 "Immacolata Concezione")
       (holiday-fixed 12 25 "Natale")
       (holiday-fixed 12 26 "Santo Stefano")
       (holiday-fixed 1 6 "Epifania")
       (holiday-easter-etc -52 "Giovedì grasso")
       (holiday-easter-etc -47 "Martedì grasso")
       (holiday-easter-etc   0 "Pasqua")
       (holiday-easter-etc  +1 "Pasquetta")
       (holiday-fixed 8 15 "Ferragosto")
       (holiday-fixed 11 1 "Ognissanti")))

;; No other religious holidays induce vacation days in Italy.
(setq holiday-bahai-holidays nil)
(setq holiday-hebrew-holidays nil)
(setq holiday-islamic-holidays nil)
#+END_SRC

   In  Italy the  weekly  calendar  starts from  Monday,  hence I  set
   =calendar-week-start-day= accordingly. It is  also nice to have the
   names of months and weekdays translated.

#+BEGIN_SRC emacs-lisp
(setq calendar-week-start-day 1
      calendar-day-name-array ["Domenica" "Lunedì" "Martedì" "Mercoledì"
                               "Giovedì" "Venerdì" "Sabato"]
      calendar-month-name-array ["Gennaio" "Febbraio" "Marzo" "Aprile" "Maggio"
                                 "Giugno" "Luglio" "Agosto" "Settembre"
                                 "Ottobre" "Novembre" "Dicembre"])
#+END_SRC

   Several packages (e.g.  Org-mode) need to recognize  what a weekday
   name  or  a  month  name is.  Package  =parse-time=  provides  this
   functionality, but it only knows about English words. I can add the
   Italian ones to  ~parse-time-weekdays~ and ~parse-time-months~ when
   package =parse-time= is loaded. I also add the timezones.

#+BEGIN_SRC emacs-lisp :tangle no
(defconst parse-time-weekdays
  '(("dom" . 0) ("lun" . 1) ("mar" . 2) ("mer" . 3) ("gio" . 4) ("ven" . 5) ("sab" . 6)
    ("domenica" . 0) ("lunedì" .  1) ("martedì" . 2) ("mercoledì" . 3)
    ("giovedì" .  4) ("venerdì" . 5) ("sabato" .  6))
  "Italian weekdays to add to `parse-time-weekdays'.")


(defconst parse-time-months-ita
  '(("gen" . 1) ("feb" . 2) ("mar" . 3) ("apr" .  4) ("mag" .  5) ("giu" .  6)
    ("lug" . 7) ("ago" . 8) ("set" . 9) ("ott" . 10) ("nov" . 11) ("dic" . 12)
    ("gennaio" . 1)   ("febbraio" . 2) ("marzo" . 3)     ("aprile" . 4)
    ("maggio" . 5)    ("giugno" . 6)   ("luglio" . 7)    ("agosto" . 8)
    ("settembre" . 9) ("ottobre" . 10) ("novembre" . 11) ("dicembre" . 12))
  "Italian manths to add to `parse-time-months'.")

(use-package parse-time
  :config
  (setq parse-time-months   (append parse-time-months parse-time-months-ita))
  (setq parse-time-weekdays (append parse-time-weekdays parse-time-weekdays-ita))
  (add-to-list 'parse-time-zoneinfo  '("cet" 3600 t) t)  ;; Central European Time
  (add-to-list 'parse-time-zoneinfo  '("cest" 7200)  t)  ;; Central European Summer Time
  )
#+END_SRC





* Appearance
** Fonts 

   The most  important visual  setup for  a text  editor is  the font.
   I include the default font with this configuration, but for Windows
   (which I  almost never use) I  have an alternative. Notice  that on
   X11 we can also use ~Xresources~ file.
  
#+BEGIN_SRC emacs-lisp
(defvar default-font
  (cond
   ((eq system-type 'windows-nt) "Consolas 14") 
   (t                            "Roboto Mono 18"))
  "The font I use by default")

(defvar symbol-font "DejaVu Sans Mono"
  "Font I use for as a fallback for some math symbols")
#+END_SRC

   I like Emacs to  open in a wide frame at the  center of the screen,
   on  startup,  at  least  on  these  systems  with  floating  window
   managers.  A  small  internal  border  puts  distance  between  the
   characters and screen  borders, and that instead  helps with tiling
   window  managers. I  disable any  other decorations.  Text is  more
   readable with some additional space between lines.

#+BEGIN_SRC emacs-lisp
(setq initial-frame-alist '((top . 0.5)    ;; center vertical position
                            (left . 0.5))) ;; center horizontal position
                            
      
(setq default-frame-alist `((font . ,default-font)
                            (height . 64)
                            (width . 120)
                            (tool-bar . nil)
                            (line-spacing . 0.2)
                            (internal-border-width . 3)
                            (border-width . 0)
                            (vertical-scroll-bars . nil)
                            (horizontal-scroll-bars . nil)
                            (left-fringe . 0)
                            (right-fringe . 0)
                            (tool-bar-lines . 0)
                            (menu-bar-line . 0)
                            ))
#+END_SRC

Some glyphs  are not  includes in  the default  font, thus  emacs uses
a  fallback which  sometimes  is less  than  desirable. In  particular
this messes  up the  alignment in  ~helm-bibtex~. For  such characters
I use an alternative fallback font.

*Hint:* To  discover the  properties of  some text  on the  screen the
command ~C-u C-x =~ gives them all: font, style, font-lock, char code.

#+BEGIN_SRC emacs-lisp
(run-with-idle-timer 1 nil
                     (lambda ()
                       (set-fontset-font t #x2318 symbol-font)   ; ⌘
                       (set-fontset-font t #x270e symbol-font)   ; ✎
))
#+END_SRC

** Theme

   The color  theme i use  is Zenburn, which features  Dark background
   and low contrast. I wonder if it is good for the eyes.

#+BEGIN_SRC emacs-lisp
;; Set theme to zenburn
(use-package zenburn-theme
  :config
  (load-theme 'zenburn t))
#+END_SRC

   Syntax/Spell  checkers  add  decorations  to  the  text  to  signal
   mistakes.  The defaults  decorations  from Zenburn  are either  too
   intrusive or too faint, so I customize them.

   - Violet for spelling mistakes
   - Red for syntax mistakes in programming languages
   - Yellow for syntax/style warnings

#+BEGIN_SRC emacs-lisp
(custom-theme-set-faces
 'zenburn
 '(flycheck-error ((t (:underline "Red"))))
 '(flycheck-warning ((t (:underline "Yellow"))))
 '(flyspell-duplicate ((t (:strike-through "magenta"))))
 '(flyspell-incorrect ((t (:underline (:color "magenta" :style wave)))))
 '(writegood-duplicates-face ((t nil)))
 '(writegood-passive-voice-face ((t (:underline (:color "Yellow" :style wave)))))
 '(writegood-weasels-face ((t (:strike-through "yellow")))))
#+END_SRC



* Prose and Technical Writing 

  I   use  Emacs   to  write   technical  papers   about  math,   code
  documentation, lecture  notes for  my courses ,  blog posts,  and to
  edit   my    websites...   and   sometimes   to    prepare   slides.
  Therefore I  need to setup  a proper  environment. I often  see many
  emacs user writing  LaTeX with for a tool which  is barely setup for
  writing code, and definitely not right for writing prose.  

  Emacs has  a lot of  potential in  prose writing, especially  if you
  ditch  LaTeX and  write  in Org  Mode or  Markdown.  In this  regard
  I suggest the following reading.

  - [[http://www.danielallington.net/2016/09/the-latex-fetish/][The LaTeX fetish (Or: Don’t write in LaTeX! It’s just for typesetting)]]
  - [[https://irreal.org/blog/?p=5054][Using Emacs for Prose]]
    
** Syntax and Grammar Check

   Too few  people on Emacs have  a decent setup for  syntax checking,
   and even  fewer have a decent  setup for grammar checking.  I don't
   claim that my setup is especially  clever, but at least it includes
   spell and grammar check in

   - Italian;
   - American English;
   - British English.

   In particular I  often write papers with colleagues  who prefer the
   British  spelling  rather  than   American  one  (which  I  favor),
   therefore I keep them both.

#+BEGIN_SRC emacs-lisp
(require 'ring)
(setq mxl-preferred-languages
      (ring-convert-sequence-to-ring '("british" "italiano" "english")))
#+END_SRC

   The entry points of my setup are three functionalities
   - Syntax/Grammar check, activated with =mxl-language-check=
   - Cycle between languages with =mxl-language-cycle=
   - Fix interactively the typos

#+BEGIN_SRC emacs-lisp
(global-set-key [f2]  'mxl-language-check)
(global-set-key (kbd "M-<f2>") 'mxl-language-cycle)
(global-set-key [M-s]  'ispell-word)
#+END_SRC

   The setup revolves on few  packages.

   - [[https://www.cs.hmc.edu/~geoff/ispell.html][Ispell]] (actually [[https://hunspell.github.io/][Hunspell]] ) for spell checking;
   - [[http://www-sop.inria.fr/members/Manuel.Serrano/flyspell/flyspell.html][Flyspell]] for spelling errors highlighting and fixing of typos;
   - [[https://languagetool.org/][LanguageTool]] and [[https://github.com/mhayashi1120/Emacs-langtool][langtool.el]] for grammar checking.

   Flyspell requires a working setup of  Ispell. I setup the latter to
   make  use  of  [[https://hunspell.github.io/][Hunspell]],  which  is  the  default  spellchecker  of
   Libre/Openoffice and Firefox.  Notice that I usually  need to place
   my  dictionaries   for  hunspell  in  a   non  standard  directory.
   Hunspell  look  them  in  the  directories  in  the  =DICPATH=  env
   variable. Be careful to have  dictionaries for all three languages,
   otherwise the setup will fail.

#+BEGIN_SRC emacs-lisp :tangle no 
(setenv "DICPATH" (concat (getenv "HOME") "..."))
#+END_SRC

   Flyspell highlights typos  and strikes out words  that are repeated
   within a  certain distance =flyspell-duplicate-distance=,  which is
   set  to 0  because  I  only want  to  signal adjacent  repetitions.
   Notice that  I activate  flyspell using the  first of  my preferred
   languages,  and that  I use  =flyspell-prog-mode= for  programming.
   Flyspell  allows a  more  interactive interface  for fixing  typos,
   contrary to the default =ispell-word=. 

#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :commands (flyspell-mode flyspell-prog-mode)
  :bind (:map flyspell-mode-map ("C-;" . nil)) 
  :config
  (setq flyspell-duplicate-distance 0     ;; signal as repetitions only adjacent pairs
        flyspell-highlight-flag t         ;; mark mispelled words
        flyspell-issue-message-flag nil   ;; silent checking
        flyspell-persistent-highlight nil ;; only highlight one word
        flyspell-use-meta-tab nil)
  (setq ispell-program-name (executable-find "hunspell"))
  (setq ispell-dictionary (ring-ref mxl-preferred-languages -1))  ;; last language by default
  (if (not ispell-program-name)
      (message "Spell checking disabled: impossible to find correctly installed 'Hunspell'.")))

(add-hook 'text-mode-hook 'flyspell-mode)
(add-hook 'prog-mode-hook 'flyspell-prog-mode)

(use-package flyspell-correct-helm
  :after flyspell
  :bind (:map flyspell-mode-map
              ("M-s" . flyspell-correct-wrapper)))
#+END_SRC

   The language  for spell and  grammar check is  the last one  in the
   ring  =mxl-preferred-languages=,  so  that  we  switch  the  chosen
   language by rotating the ring. Mode-line will signal which one that
   is.

#+BEGIN_SRC emacs-lisp
(defun mxl-set-flyspell-modeline ()
  "Refresh the flyspell modeline with language indicator"
  (interactive)
  (setq flyspell-mode-line-string
        (let ((lang (or ispell-local-dictionary ispell-dictionary nil)))
          (cond
           ((string-equal lang "italiano") " [IT]")
           ((string-equal lang "english")  " [EN]")
           ((string-equal lang "british")  " [GB]")
           (t "")))))


(defadvice ispell-init-process (after ispell-init-process-after activate)
  (mxl-set-flyspell-modeline))

#+END_SRC

   This is the code for cycling among the preferred languages. At each
   rotation the  settings for both  the spell checker and  the grammar
   checker are updated.

#+BEGIN_SRC emacs-lisp
(defun mxl-language-cycle ()
  "Switch between spell checking languages, in the current buffer."
  (interactive)
  (let* ((lang-ring mxl-preferred-languages)
         (lang (ring-ref lang-ring -1)))
        (ring-insert lang-ring lang)
        (ispell-change-dictionary lang)
        (setq langtool-default-language 
              (cond
               ((string-equal lang "italiano") "it")
               ((string-equal lang "english")  "en")
               ((string-equal lang "british")  "en-GB")
               (t "")))))
#+END_SRC

    Grammar check with Langtool is  reasonably easy to setup. The only
    caveat is  that it need  to be  installed. When installed,  we use
    =langtool-disabled-rules=   to   deactivate  some   checks   (e.g.
    whitespaces) which generates too many false positives.

#+BEGIN_SRC emacs-lisp
(when (file-directory-p "/usr/local/share/languagetool/")
  (use-package langtool
    :init
    (setq langtool-language-tool-jar "/usr/local/share/languagetool/languagetool-commandline.jar")
    :config
    (setq langtool-mother-tongue "it")'
    (setq langtool-disabled-rules "WHITESPACE_RULE")
    :commands (langtool-check langtool-check-buffer langtool-switch-default-language)))

#+END_SRC

    The  last component  is  a  single function  =mxl-language-check=.
    Allows to
    - pick between syntax and grammar check in the current language;
    - stop grammar check if one is running;
#+BEGIN_SRC emacs-lisp

;; Spell/Grammar check command
(defun mxl-language-check () 
  "Launch either spell check or grammar check

Offer a choice between spell checking the buffer, or grammar
checking it. It a region is active the spell check will be
performed on that region. If some grammar checking session is
open, the command will just close it.
"
  (interactive)
   ;; If grammar check is active, close it
  (if (and (boundp 'langtool-mode-line-message)
           langtool-mode-line-message)
      (langtool-check-done)
    ;; otherwise offer a choice
    (let* ((choices '("spelling" "grammar" "none"))
           (selection (ido-completing-read "Check for " choices )))
      (pcase selection
        ("spelling"
         (if (region-active-p)
             (call-interactively 'ispell-region)
           (ispell-buffer)))
        ("grammar" (langtool-check-buffer))
        (otherwise nil))
      )))
#+END_SRC



* Programming
  
** Generic Syntax highlighting

   Of  course   every  mode   include  syntax  highlighting   for  the
   corresponding  type of  file.  There are  more  "semantic" ways  to
   highlight pieces of codes. Many of these syntax highlight packages are described in

   - [[http://www.wilfred.me.uk/blog/2014/09/27/the-definitive-guide-to-syntax-highlighting/][The Definitive Guide To Syntax Highlighting]]


   The first package color parenthesis  with dirrerent colors, so that
   matching  parenthesis have  the same  color. Of  course after  some
   nesting  the   colors  repeat.   This  is  especially   useful  for
   lisp programming.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :init (setq rainbow-delimiters-max-face-count 4)
  :commands rainbow-delimiters-mode
  :hook ((emacs-lisp-mode . rainbow-delimiters-mode)
         (lisp-interaction-mode . rainbow-delimiters-mode)))
#+END_SRC

   The next package colors each identifier, so that the occurrences of
   that identifier have the same color than the definition.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-identifiers
  :commands rainbow-identifiers-mode)
#+END_SRC


   Next  package sets  a different  background color  for each  nested
   code block.

#+BEGIN_SRC emacs-lisp
(use-package highlight-blocks
  :commands highlight-blocks-mode)
#+END_SRC

   Next package highlights occurrences of the symbol under the point.

#+BEGIN_SRC emacs-lisp
(use-package highlight-symbol
  :commands highlight-symbol-mode)
#+END_SRC

   Next package highlight  lisp quotes, so it is not  useful for other
   languages (maybe Scheme?).

#+BEGIN_SRC emacs-lisp
(use-package highlight-quoted
  :commands highlight-quoted-mode)
#+END_SRC

  Next package is  useful for emacs lisp. It highlight  names that are
  defined  in   emacs  lisp,  differentiating   functions,  variables,
  builtins, ...

#+BEGIN_SRC emacs-lisp
(use-package  highlight-defined  :ensure t  
  :commands highlight-defined-mode)
#+END_SRC

** Fixing Errors

We all  know most of development  time is spend looking  for error and
fixing them. Here we set the  basic function that Emacs has to compile
and  navigate  the errors.  In  particular  I  want to  integrate  the
~previous-error~  and  ~next-error~  function of  various  type  (e.g.
=Flycheck=, =*grep*=, =*compilation*=). I also implement a function to
show/hide the error buffer, called ~mxl-toggle-error-window~.

The  function keys  from =F9=  to =F12=  are reserved  for development
needs, and  the functionality  strongly depends  on the  current mode.

#+BEGIN_SRC emacs-lisp
(global-set-key [f9]  'recompile)
(global-set-key (kbd "M-<f9>")  'compile)
(global-set-key [f10] 'gdb)
(global-set-key [f11] 'previous-error)
(global-set-key [f12] 'next-error)
(global-set-key [M-f11] 'mxl-toggle-error-window)
(global-set-key [M-f12] 'mxl-toggle-error-window)
#+END_SRC

In order  to toggle the  visibility of the error  list I had  to write
a surprisingly complex and incomplete function. I need to extend it as
long as  I come  across further  types of  error buffers.  Since LaTeX
error  management is  a bit  special, I  have to  do a  specific setup
for that.


#+BEGIN_SRC emacs-lisp
(defun mxl-toggle-error-window (&optional buffer-or-name)
  "Toggle the visibility or the error list.

The error list is the buffer that contains the errors which can
be navigated by `next-error' and `previous-error'. The function
visualizes the error 
"
  (interactive)
  (let* ((std-error-buffers '("*grep*" "*compilation*"))
         (current-error-bon (cond
                             (buffer-or-name (get-buffer buffer-or-name))     ;; input argument 
                             ((eq next-error-function            ;; flycheck errors
                                  'flycheck-next-error-function) 
                              "*Flycheck errors*")
                             ((member (buffer-name next-error-last-buffer)
                                      std-error-buffers)
                              next-error-last-buffer)
                             (t nil)))      ;; *compilation*, *grep*,...
         buffer
         name
         window)
    
    (when current-error-bon
      (setq buffer (get-buffer current-error-bon))
      (setq name (buffer-name buffer))
      (setq window (get-buffer-window buffer))
      (if window
          (progn (message (concat "Closing error list: " name))
                 (delete-window window))
        (message (concat "Opening error list: " name))
        (display-buffer buffer)))))
#+END_SRC

   Most programming languages are supported by =flycheck=, a tool that
   automatically   checks  the   buffer  for   error  while   writing.
   Let's  activate it  by default.  In supported  languages =flycheck=
   activates, assuming all needed tools for that language are present.
   Use   =flycheck-verify-setup=    to   investigate    the   checkers
   enabled/disabled/available in a buffer.

#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook #'global-flycheck-mode)
#+END_SRC

   Let's do a bit of setup  of =flycheck=, in particular how the error
   are signaled to the user.

#+BEGIN_SRC emacs-lisp
(setq flycheck-disabled-checkers '(tex-chktex)
      flycheck-display-errors-delay 0.1
      flycheck-highlighting-mode 'symbols
      flycheck-idle-change-delay 1.0)
#+END_SRC

 



** Python

   Python  is  the programming  language  I  am using  most  nowadays.
   My setup is  not very sophisticated right now. Earlier  it was more
   complex  but  it  was  breaking  quite  often  at  each  change  of
   technology, Ipython, and so on...

   My configuration  is based around the  default =python.el= included
   with  Emacs   (there  are   indeed  other  python   modes  around).
   Furthermore it uses
   - =anaconda-mode= and =company-anacon= for completion;
   - =pyenv= to manage the virtual environments.
   - standard  python   as  interactive  shell  (Ipython   prompt  and
     completion tend to confuse Emacs if not well configured).

   Binaries will be found in the =pyenv= paths.

#+BEGIN_SRC emacs-lisp
(add-to-list 'exec-path (concat (getenv "HOME") "/.pyenv/shims"))
(add-to-list 'exec-path (concat (getenv "HOME") "/.pyenv/bin"))
(environment-add-path (concat (getenv "HOME") "/.pyenv/shims"))
(environment-add-path (concat (getenv "HOME") "/.pyenv/bin"))
#+END_SRC

We  set  the key  F9  to  launch the  tests  for  the python  program.
In particular we use  =python-pytest-dispatch=, which shows a complete
interface similar  to Magit,  and allows  various options  for testing
(i.e. test a single file/module).

#+BEGIN_SRC emacs-lisp
(use-package python-pytest
  :commands python-pytest-dispatch
  :bind (:map python-mode-map
         ("<f9>" . python-pytest-dispatch)))
#+END_SRC



  Using the key F10 I can  toggle the prompt shell buffer connected to
  this python buffer.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load "python"
  (define-key python-mode-map (kbd "<f10>") 'python-shell-switch-to-shell)
  (define-key inferior-python-mode-map (kbd "<f10>") 'delete-window))
#+END_SRC

   Autocompletion is based around  Anaconda Mode, paired with Company.
   We  also use  Anacoda for  code navigation  using =M-.=  and =M-,=.
   Unfortunately =anaconda-mode= does not work with Python 3.8, so for
   now I have to stay with Python 3.7.

#+BEGIN_SRC emacs-lisp
(use-package anaconda-mode
  :diminish nil
  :commands anaconda-mode
  :init
  (add-hook 'python-mode-hook 'anaconda-mode)
  (add-hook 'python-mode-hook 'anaconda-eldoc-mode)
  :config
  (define-key anaconda-mode-map  (kbd "M-/") 'anaconda-mode-show-doc)
  (define-key anaconda-mode-map  (kbd "M-.") 'anaconda-mode-find-definitions)
  (define-key anaconda-mode-map  (kbd "M-,") 'pop-tag-mark)
  (define-key anaconda-mode-map  (kbd "M-r") nil))

;; Auto completion
(use-package company-anaconda
  :after (anaconda-mode company)
  :commands company-anaconda
  :config (add-to-list 'company-backends 'company-anaconda))
#+END_SRC


  I  have  not reached  a  definitive  configuration regarding  syntax
  checking, but for  now I am using either [[https://www.pylint.org/][Pylint]]  or [[https://flake8.pycqa.org/en/latest/][Flake8]] which are
  run  by [[https://www.flycheck.org/][Flycheck]],  an  emacs package  which  highlight code  errors.
  Furthermore I  use [[https://github.com/google/yapf][Yapf]]  to enforce  code formatting,  together with
  [[https://github.com/JorisE/yapfify][Yapfify]] emacs package.  I tried [[https://github.com/paetzke/py-yapf.el][Py-Yapf]] before but it  had some bugs
  open for a while, like the  fact that it empties the kill-ring every
  time you save python code.

#+BEGIN_SRC emacs-lisp
(add-hook 'python-mode-hook 'flycheck-mode)
(add-to-list 'flycheck-disabled-checkers 'python-mypy)

(use-package yapfify
  :diminish yapf-mode 
  :hook (python-mode . yapf-mode))
#+END_SRC

  Emacs is able to find the appropriate =pyenv= Python Environment and
  to  load  it  automatically.  Which is  useful  for  running  syntax
  checkers or  the Python Shell.  Notice that by  default =pyenv-mode=
  sets key  bidings on =C-c C-s=  and =C-c C-u=, which  conflicts with
  tons  of  stuff,  including  =org-schedule=. Hence  I  disable  such
  bindings,  since  =pyenv-mode-auto=   sets  the  python  environment
  automatically according  =.python-version=. In the rare  cases where
  I  need  to  switch  environment  I usually  run  the  command  from
  the minibuffer.

#+BEGIN_SRC emacs-lisp
(use-package pyenv-mode
  :bind (:map pyenv-mode-map
         ("C-c C-s" . nil)
         ("C-c C-u" . nil))
  :commands (pyenv-mode-set pyenv-mode-unset pyenv-mode))

(use-package pyenv-mode-auto
  :hook (find-file . pyenv-mode-auto-hook)
  :config (pyenv-mode))
#+END_SRC

  Of course standard indentation is 4.

#+BEGIN_SRC emacs-lisp
(setq python-indent-guess-indent-offset nil)
(setq python-indent-offset 4)
#+END_SRC


** Shell programming

   I don't  have a  particularly clever  setup for  shell programming,
   even though  I should probably  take it more seriously.  There many
   bad  patterns in  shell programming  and  few good  ones. I  should
   massively use  snippets. One  thing that is  needed is  to activate
   shell mode automatically for [[http://zsh.sourceforge.net/][Zsh]] scripts.

   I don't know  muc shell programming. Maybe I  should make templates
   for good bash programming practices as in 
   - [[http://mywiki.wooledge.org/BashPitfalls][Bash Pitfalls]]
   - [[http://redsymbol.net/articles/unofficial-bash-strict-mode/][Bash Strict mode]] 

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.zsh" . sh-mode))
#+END_SRC

   Furthermore   it  is   possible   to  edit   command  lines   while
   using terminal. This setup activates ~sh-mode~ there as well

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("zsh[a-zA-Z0-9]*" . sh-mode))
(add-to-list 'auto-mode-alist '("bash-fc-[0-9]*"  . sh-mode))
#+END_SRC

   There  is   a  nice   syntax  checker   for  shell   script  called
   =shellcheck=,  which  is  a  godsend  considering  how  brittle  is
   the language.

** Copyright notice and timestamps

   Automatic  update  of  the   copyright  notices  and  time  stamps.
   Useful to keep additional track  about files age, regardless of git
   history.

#+BEGIN_SRC emacs-lisp
(setq copyright-query nil)                       ; do not ask before a copyright 
(add-hook 'before-save-hook 'copyright-update)   ; update copyright if present
(add-hook 'before-save-hook 'time-stamp)         ; insert timestamp
#+END_SRC

* Math packages

  I don't use math packages often,  and I should probably use them way
  more. Anyway  there is some  support for them  in Emacs, so  why not
  having a basic setup?

  Mathematica, Octave  and Matlab all  use files with  =.m= extension,
  which is the same extension of Objective-C files. Since I do not use
  either much, I don't need to fiddle with =auto-mode-alist=.

** Matlab

   There is =run-octave= so I guess =run=matlab= should exists.

#+BEGIN_SRC emacs-lisp
(use-package matlab
  :init
  (setq matlab-shell-command
        (or
         (executable-find "matlab")
         (executable-find "/usr/local/bin/matlab")
         (executable-find "/Applications/Matlab.app/bin/matlab")))
  (setq matlab-indent-function-body t)
  :commands (matlab-mode matlab-shell))


(defalias 'run-matlab 'matlab-shell)
#+END_SRC


** Mathematica

   Nowadays Mathematica  is a  super-cool software  that works  on the
   network  and has  great AI.  I guess  it is  nicer to  use via  the
   appropriate GUI or on the web. Still, emacs rocks.

#+BEGIN_SRC emacs-lisp
(use-package wolfram-mode
  :init
  (setq wolfram-program
      (or
       (executable-find "math")
       (executable-find "/usr/local/bin/math")
       (executable-find "/Applications/Mathematica.app/Contents/MacOS/MathKernel")))
  :commands (run-wolfram wolfram-mode))

(defalias 'run-mathematica 'run-wolfram)
#+END_SRC



* Other features
** Backup and autosave of files


   Emacs  manages  multiple  backups  for files,  and  furthermore  it
   remembers to  save stuff from time  to time. I'd rather  put all my
   backups and autosaves in a specific folder.

#+BEGIN_SRC emacs-lisp
(defvar mxl-autosave-dir "~/.emacs.d/autosaves/")
(defvar mxl-backup-dir   "~/.emacs.d/backups/")
(make-directory mxl-autosave-dir t)
(make-directory mxl-backup-dir t)
#+END_SRC


   First I setup the autosave feature

#+BEGIN_SRC emacs-lisp
(setq tramp-auto-save-directory mxl-autosave-dir)
(setq auto-save-file-name-transforms
      `((".*" ,mxl-autosave-dir t)))
#+END_SRC

   then I setup the backup features, where copies of old versions are
   kept. Disable backups for remote files.

#+BEGIN_SRC emacs-lisp
(setq make-backup-files t)

(setq version-control nil)

(setq delete-old-versions t) ;; silently delete old versions
(setq kept-new-versions 3)   ;; number of newest versions to keep
(setq kept-old-versions 2)   ;; number of oldest versions to keep
(setq backup-by-copying t)
(setq backup-by-copying-when-linked t)

(setq backup-directory-alist
      `(("." . ,mxl-backup-dir)                ;; location for local files
        (,tramp-file-name-regexp .  nil)))     ;; disable for remote files

#+END_SRC

** Bookmarks

   If you are  like me you have  several files you visit  on a regular
   bases,  for some  periods of  time. E.g.,  lecture folders,  course
   journal, the tex files for the  paper you are currently working on.
   It is convenient to bookmark  such locations, but the bookmark file
   should be in some private versioned folder.

#+BEGIN_SRC emacs-lisp
   (setq bookmark-default-file "~/personal/conf/emacs.bookmarks")
#+END_SRC

   I use =helm-mini=  to access and set bookmarks, but  it is possible
   to edit  and delete them with  command =bookmark-bmenu-list=, bound
   to =C-x r l=.

#+BEGIN_SRC emacs-lisp
(setq helm-mini-default-sources '(helm-source-buffers-list
                                  helm-source-recentf
                                  helm-source-bookmarks
                                  helm-source-buffer-not-found))
#+END_SRC

** Hide some buffers in Helm

   Some buffers  clutter selection menus  and there are no  reasons to
   visit them.  For example the  buffer =*import calendar*=  just runs
   the  script   which  imports  my  google   calendars  in  org-mode.
   Better hide them from the buffer list.

#+BEGIN_SRC emacs-lisp
(setq helm-boring-buffer-regexp-list
  '("\\` " "\\`\\*helm" "\\`\\*Echo Area" "\\`\\*Minibuf" "\\`\\*Echo Area" 
    "\\`\\*import calendar*"
    "\\`\\*Help"
    "\\`\\*Disabled Command"
    "\\`\\*Backtrace"))

(setq helm-white-buffer-regexp-list nil)

#+END_SRC
